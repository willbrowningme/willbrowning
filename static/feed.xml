<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://willbrowning.me/feed.xml</id>
    <title>Will Browning - Feed</title>
    <updated>2020-11-04T11:43:32Z</updated>
    <generator>Feed for Node.js</generator>
    <link rel="alternate" href="https://willbrowning.me/feed.xml"/>
    <subtitle>A feed for willbrowning.me</subtitle>
    <icon>https://willbrowning.me/favicon.ico</icon>
    <rights>All rights reserved, Will Browning</rights>
    <entry>
        <title type="html"><![CDATA[Automated Offsite Encrypted Backups with Borg Backup]]></title>
        <id>https://willbrowning.me/automated-offsite-encrypted-backups-with-borg-backup</id>
        <link href="https://willbrowning.me/automated-offsite-encrypted-backups-with-borg-backup">
        </link>
        <updated>2019-06-25T13:02:59Z</updated>
        <summary type="html"><![CDATA[In this post I'll be showing you how to set up Borg Backup to backup the important files on your VPS or local work station to a remote repository. For this tutorial I'm going to be using borgbase.com as the remote repository provider but there are other options you can choose.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://borgbase.com">Borgbase.com</a> was created specifically to host Borg repositories, it has a nice free plan that gives you 5GB of storages and allows upto 2 repositories. If you have a small VPS then this might be enough for you.</p>
<p>If you don&#39;t want to use borgbase you could use <a href="https://www.rsync.net/products/attic.html">rysnc.net</a> or even another VPS that you run.</p>
<p>This tutorial will be done on a fresh Digital Ocean droplet with Ubuntu 18.04. </p>
<p>Commands will be run by a user named johndoe with sudo privileges.</p>
<h2 id="install-borg-backup">Install Borg Backup</h2>
<p>First things first we need to install Borg, luckily we can find it in Ubuntu&#39;s software repositories.</p>
<pre><code class="language-bash">sudo apt update
sudo apt install borgbackup</code></pre>
<p>You can check everything worked correctly by running <code>borg --version</code>, you should see something like <code>borg 1.1.5</code>, which is the version at the time of writing this post.</p>
<h2 id="install-python-3-and-pip">Install Python 3 and PIP</h2>
<p>Now we need to install Python 3 along with PIP so that we can install Borgmatic.</p>
<p>Borgmatic is a wrapper for Borg that allows us to manage backups with easy to use configuration files. It is not required to use Borg but I&#39;m going to use it here to show you how it works.</p>
<p>You may already have Python 3 installed (I think 18.04 does by default). You can run the commands below to check.</p>
<pre><code class="language-bash">python --version
python3 --version</code></pre>
<p>If Python 3 is already installed check what version of Python PIP is currently using, it might not be installed at all.</p>
<pre><code class="language-bash">pip --version
pip3 --version</code></pre>
<p>If PIP returns (python 2.7) at the end or it is not installed at all then we need to install PIP for Python 3.</p>
<pre><code class="language-bash">sudo apt install python3-pip python3-setuptools</code></pre>
<p>Make sure everything was installed correctly by running <code>pip3 --version</code>.</p>
<p>Next install the following package that is used by Borgmatic.</p>
<pre><code class="language-bash">pip3 install wheel</code></pre>
<h2 id="install-borgmatic">Install Borgmatic</h2>
<p>Using PIP install Borgmatic for your user (johndoe in my case).</p>
<pre><code class="language-bash">pip3 install --user --upgrade borgmatic</code></pre>
<p>You may need to edit your <code>~/.bashrc</code> file to include these commands in your PATH by adding the following to the end of the file.</p>
<pre><code>export PATH=&quot;$HOME/.local/bin:$PATH&quot;</code></pre><p>Then running <code>source ~/.bashrc</code> to update it for your current session.</p>
<p>Next we can publish the default configuration file by running the following.</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; generate-borgmatic-config</code></pre>
<p>The reason we pass <code>env &quot;PATH=$PATH&quot;</code> is to make sure we still have the borgmatic commands in our PATH when running sudo.</p>
<p>We could edit the <code>secure_path</code> in /etc/sudoers to include /home/johndoe/.local/bin but I&#39;ll leave it as it is for this tutorial.</p>
<p>Before we go and edit the config file we&#39;ll first generate a new key pair and create our remote repository in borgbase.</p>
<h2 id="generate-new-ssh-key-pair">Generate New ssh Key Pair</h2>
<p>To generate the key pair run the following command:</p>
<pre><code class="language-bash">ssh-keygen -t ed25519 -a 100</code></pre>
<p>Call it <code>/home/johndoe/.ssh/borg_id_ed25519</code> making sure to replace <code>johndoe</code> with the your username and leave the passphrase as empty.</p>
<p>This will generate an Ed25519 key, which is shorter and faster than a comparable RSA key.</p>
<pre><code class="language-bash">cat ~/.ssh/borg_id_ed25519.pub</code></pre>
<p>Copy this <strong>public</strong> key and add it to your BorgBase account by clicking &quot;ACCOUNT&quot; and then &quot;ADD KEY&quot;. </p>
<h2 id="create-repository-in-borgbase">Create Repository in BorgBase</h2>
<p>Give it a name you&#39;ll recognise for your server and add the new key above to the Append-only access section.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/06/25/5d121b2f717a4borgbase-repo.png" alt="BorgBase Repository"></p>
</div>

<p>Copy the repo path as we&#39;ll be adding it to the config file next, it will be something like <code>c89dks9m@c89dks9m.repo.borgbase.com:repo</code>.</p>
<h2 id="editing-the-config-file">Editing the Config File</h2>
<p>Open /etc/borgmatic/config.yaml by running <code>sudo nano /etc/borgmatic/config.yaml</code> and edit its contents to look something like this:</p>
<pre><code class="language-yaml"># Where to look for files to backup, and where to store those backups. See
# https://borgbackup.readthedocs.io/en/stable/quickstart.html and
# https://borgbackup.readthedocs.io/en/stable/usage.html#borg-create for details.
location:
    # List of source directories to backup (required). Globs and tildes are expanded.
    source_directories:
        - /root
        - /home
        - /etc
        - /var/log/syslog*

    # Paths to local or remote repositories (required). Tildes are expanded. Multiple
    # repositories are backed up to in sequence. See ssh_command for SSH options like
    # identity file or port.
    repositories:
        - YOUR-REPO-ID@YOUR-REPO-ID.repo.borgbase.com:repo

    # Stay in same file system (do not cross mount points). Defaults to false.
    #one_file_system: true

    # Only store/extract numeric user and group identifiers. Defaults to false.
    #numeric_owner: true

    # Use Borg&#39;s --read-special flag to allow backup of block and other special
    # devices. Use with caution, as it will lead to problems if used when
    # backing up special devices such as /dev/zero. Defaults to false.
    #read_special: false

    # Record bsdflags (e.g. NODUMP, IMMUTABLE) in archive. Defaults to true.
    #bsd_flags: true

    # Mode in which to operate the files cache. See
    # https://borgbackup.readthedocs.io/en/stable/usage/create.html#description for
    # details. Defaults to &quot;ctime,size,inode&quot;.
    #files_cache: ctime,size,inode

    # Alternate Borg local executable. Defaults to &quot;borg&quot;.
    #local_path: borg1

    # Alternate Borg remote executable. Defaults to &quot;borg&quot;.
    #remote_path: borg1

    # Any paths matching these patterns are included/excluded from backups. Globs are
    # expanded. (Tildes are not.) Note that Borg considers this option experimental.
    # See the output of &quot;borg help patterns&quot; for more details. Quote any value if it
    # contains leading punctuation, so it parses correctly.
    #patterns:
    #    - R /
    #    - &#39;- /home/*/.cache&#39;
    #    - + /home/susan
    #    - &#39;- /home/*&#39;

    # Read include/exclude patterns from one or more separate named files, one pattern
    # per line. Note that Borg considers this option experimental. See the output of
    # &quot;borg help patterns&quot; for more details.
    #patterns_from:
    #    - /etc/borgmatic/patterns

    # Any paths matching these patterns are excluded from backups. Globs and tildes
    # are expanded. See the output of &quot;borg help patterns&quot; for more details.
    exclude_patterns:
        - &#39;*.pyc&#39;
        - ~/*/.cache
    #    - /etc/ssl

    # Read exclude patterns from one or more separate named files, one pattern per
    # line. See the output of &quot;borg help patterns&quot; for more details.
    #exclude_from:
    #    - /etc/borgmatic/excludes

    # Exclude directories that contain a CACHEDIR.TAG file. See
    # http://www.brynosaurus.com/cachedir/spec.html for details. Defaults to false.
    exclude_caches: true

    # Exclude directories that contain a file with the given filename. Defaults to not
    # set.
    exclude_if_present: .nobackup

# Repository storage options. See
# https://borgbackup.readthedocs.io/en/stable/usage.html#borg-create and
# https://borgbackup.readthedocs.io/en/stable/usage/general.html#environment-variables for
# details.
storage:
    # The standard output of this command is used to unlock the encryption key. Only
    # use on repositories that were initialized with passcommand/repokey encryption.
    # Note that if both encryption_passcommand and encryption_passphrase are set,
    # then encryption_passphrase takes precedence. Defaults to not set.
    #encryption_passcommand: secret-tool lookup borg-repository repo-name

    # Passphrase to unlock the encryption key with. Only use on repositories that were
    # initialized with passphrase/repokey encryption. Quote the value if it contains
    # punctuation, so it parses correctly. And backslash any quote or backslash
    # literals as well. Defaults to not set.
    encryption_passphrase: CHANGE-ME-TO-A-LONG-SECURE-PASSPHRASE

    # Number of seconds between each checkpoint during a long-running backup. See
    # https://borgbackup.readthedocs.io/en/stable/faq.html#if-a-backup-stops-mid-way-does-the-already-backed-up-data-stay-there
    # for details. Defaults to checkpoints every 1800 seconds (30 minutes).
    #checkpoint_interval: 1800

    # Specify the parameters passed to then chunker (CHUNK_MIN_EXP, CHUNK_MAX_EXP,
    # HASH_MASK_BITS, HASH_WINDOW_SIZE). See https://borgbackup.readthedocs.io/en/stable/internals.html
    # for details. Defaults to &quot;19,23,21,4095&quot;.
    #chunker_params: 19,23,21,4095

    # Type of compression to use when creating archives. See
    # https://borgbackup.readthedocs.org/en/stable/usage.html#borg-create for details.
    # Defaults to &quot;lz4&quot;.
    compression: auto,zstd

    # Remote network upload rate limit in kiBytes/second. Defaults to unlimited.
    #remote_rate_limit: 100

    # Command to use instead of &quot;ssh&quot;. This can be used to specify ssh options.
    # Defaults to not set.
    ssh_command: ssh -i /home/johndoe/.ssh/borg_id_ed25519

    # Base path used for various Borg directories. Defaults to $HOME, ~$USER, or ~.
    # See https://borgbackup.readthedocs.io/en/stable/usage/general.html#environment-variables for details.
    #borg_base_directory: /path/to/base

    # Path for Borg configuration files. Defaults to $borg_base_directory/.config/borg
    #borg_config_directory: /path/to/base/config

    # Path for Borg cache files. Defaults to $borg_base_directory/.cache/borg
    #borg_cache_directory: /path/to/base/cache

    # Path for Borg security and encryption nonce files. Defaults to $borg_base_directory/.config/borg/security
    #borg_security_directory: /path/to/base/config/security

    # Path for Borg encryption key files. Defaults to $borg_base_directory/.config/borg/keys
    #borg_keys_directory: /path/to/base/config/keys

    # Umask to be used for borg create. Defaults to 0077.
    #umask: 0077

    # Maximum seconds to wait for acquiring a repository/cache lock. Defaults to 1.
    #lock_wait: 5

    # Name of the archive. Borg placeholders can be used. See the output of
    # &quot;borg help placeholders&quot; for details. Defaults to
    # &quot;{hostname}-{now:%Y-%m-%dT%H:%M:%S.%f}&quot;. If you specify this option, you must
    # also specify a prefix in the retention section to avoid accidental pruning of
    # archives with a different archive name format. And you should also specify a
    # prefix in the consistency section as well.
    archive_name_format: &#39;{hostname}-{now}&#39;

# Retention policy for how many backups to keep in each category. See
# https://borgbackup.readthedocs.org/en/stable/usage.html#borg-prune for details.
# At least one of the &quot;keep&quot; options is required for pruning to work. See
# https://torsion.org/borgmatic/docs/how-to/deal-with-very-large-backups/
# if you&#39;d like to skip pruning entirely.
retention:
    # Keep all archives within this time interval.
    #keep_within: 3H

    # Number of secondly archives to keep.
    #keep_secondly: 60

    # Number of minutely archives to keep.
    #keep_minutely: 60

    # Number of hourly archives to keep.
    #keep_hourly: 24

    # Number of daily archives to keep.
    keep_daily: 7

    # Number of weekly archives to keep.
    keep_weekly: 4

    # Number of monthly archives to keep.
    keep_monthly: 6

    # Number of yearly archives to keep.
    keep_yearly: 1

    # When pruning, only consider archive names starting with this prefix.
    # Borg placeholders can be used. See the output of &quot;borg help placeholders&quot; for
    # details. Defaults to &quot;{hostname}-&quot;.
    prefix: &#39;{hostname}-&#39;

# Consistency checks to run after backups. See
# https://borgbackup.readthedocs.org/en/stable/usage.html#borg-check and
# https://borgbackup.readthedocs.org/en/stable/usage.html#borg-extract for details.
consistency:
    # List of one or more consistency checks to run: &quot;repository&quot;, &quot;archives&quot;, and/or
    # &quot;extract&quot;. Defaults to &quot;repository&quot; and &quot;archives&quot;. Set to &quot;disabled&quot; to disable
    # all consistency checks. &quot;repository&quot; checks the consistency of the repository,
    # &quot;archive&quot; checks all of the archives, and &quot;extract&quot; does an extraction dry-run
    # of the most recent archive.
    checks:
        - repository
        - archives

    # Paths to a subset of the repositories in the location section on which to run
    # consistency checks. Handy in case some of your repositories are very large, and
    # so running consistency checks on them would take too long. Defaults to running
    # consistency checks on all repositories configured in the location section.
    #check_repositories:
    #    - user@backupserver:sourcehostname.borg

    # Restrict the number of checked archives to the last n. Applies only to the &quot;archives&quot; check. Defaults to checking all archives.
    check_last: 3

    # When performing the &quot;archives&quot; check, only consider archive names starting with
    # this prefix. Borg placeholders can be used. See the output of
    # &quot;borg help placeholders&quot; for details. Defaults to &quot;{hostname}-&quot;.
    prefix: &#39;{hostname}-&#39;

# Options for customizing borgmatic&#39;s own output and logging.
#output:
    # Apply color to console output. Can be overridden with --no-color command-line
    # flag. Defaults to true.
    #color: false

# Shell commands or scripts to execute before and after a backup or if an error has occurred.
# IMPORTANT: All provided commands and scripts are executed with user permissions of borgmatic.
# Do not forget to set secure permissions on this file as well as on any script listed (chmod 0700) to
# prevent potential shell injection or privilege escalation.
hooks:
    # List of one or more shell commands or scripts to execute before creating a backup.
    before_backup:
        - echo &quot;`date` - Starting backup&quot;
        - mysqldump --all-databases &gt; /home/johndoe/databases.sql

    # List of one or more shell commands or scripts to execute after creating a backup.
    after_backup:
        - echo &quot;`date` - Finished backup&quot;
        - rm /home/johndoe/databases.sql

    # List of one or more shell commands or scripts to execute in case an exception has occurred.
    #on_error:
    #    - echo &quot;Error while creating a backup.&quot;

    # Umask used when executing hooks. Defaults to the umask that borgmatic is run with.
    #umask: 0077</code></pre>
<p>Make sure to change the encryption passphrase to a long secure secret and also update the repository addresss. Change the files to backup to suit your specific needs.</p>
<p>If you want to include your databases in the backup then you can use the before and after hooks (make sure again to change johndoe to the name of your user). If not then just comment out these lines. </p>
<p>Make sure to backup your passphrase as you won&#39;t be able to decrypt your backups without it.</p>
<p>Run the following command to check for any configuration errors.</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; validate-borgmatic-config</code></pre>
<p>If everything is okay you should see <code>All given configuration files are valid: /etc/borgmatic/config.yaml</code>.</p>
<h2 id="initialise-the-backup-repository">Initialise the Backup Repository</h2>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic init --encryption repokey-blake2</code></pre>
<p>You&#39;ll be asked about the authenticity of the host when connecting for the first time. Check the ECDSA key fingerprint against the one shown in BorgBase by hovering over the fingerprint icon on the repository check the SHA256 to make sure it matches.</p>
<p>Then enter yes to continue. You&#39;ll see a message saying Repository .... does not exist. This is simply becuase it it the first time you are running the command and it is currently being created.</p>
<h2 id="creating-your-first-backup">Creating your First Backup</h2>
<p>To create our first backup we can simply run the following:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic --verbosity 1</code></pre>
<p>The verbosity flag simply tells Borgmatic to print out all the files it is adding, quickly check through the list to make sure they all look correct as per your /etc/borgmatic/config.yaml file.</p>
<h2 id="automating-backups-with-a-cron-job">Automating Backups with a Cron Job</h2>
<p>Since we&#39;re using sudo to run borgmatic we need to edit our /etc/sudoers file to allow passwordless sudo for that particular command whilst running our cron job.</p>
<pre><code class="language-bash">sudo visudo</code></pre>
<p>At the end of the file add the following:</p>
<pre><code>johndoe ALL=(root) NOPASSWD: /home/johndoe/.local/bin/borgmatic</code></pre><p>This will allow us to run our cron job with sudo and not be prompted for a sudo password.</p>
<p>To add a new cron job type <code>crontab -e</code> in the terminal.</p>
<p>Add the following line to the end of the file.</p>
<pre><code>0 0 * * * sudo /home/johndoe/.local/bin/borgmatic</code></pre><p>This will create a new backup everyday at midnight.</p>
<h2 id="multiple-repositories-for-differents-apps">Multiple Repositories for Differents Apps</h2>
<p>If you would like to separate your apps in different repositories or even to create a repository for backing up just your database you can create a new config file by running:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; generate-borgmatic-config --destination /etc/borgmatic.d/app1.yaml</code></pre>
<p>You can then go and update the new config file to your liking e.g. to make an hourly database backup.</p>
<p>When setting up cron jobs for backups as above you can pass <code>--config /etc/borgmatic.d/app1.yaml</code> to tell Borgmatic to only run the backup for that repository.</p>
<pre><code>0 * * * * sudo /home/johndoe/.local/bin/borgmatic --config /etc/borgmatic.d/app1.yaml</code></pre><p>This will run our app1 config file every hour.</p>
<h2 id="checking-backups">Checking Backups</h2>
<p>To see all of your backup archives you can run:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic list</code></pre>
<p>To see details about usage and the size of archives you can run:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic info</code></pre>
<h2 id="restoring-backups">Restoring Backups</h2>
<p>To restore a backup you need to first get the name of the archive using the above <code>borgmatic list</code> command.</p>
<p>The list command should display something like this:</p>
<pre><code>host-2019-01-01T04:05:06.070809      Tue, 2019-01-01 04:05:06 [...]
host-2019-01-02T04:06:07.080910      Wed, 2019-01-02 04:06:07 [...]</code></pre><p>Then you can simply run:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic extract --archive host-2019-01-02T04:06:07.080910</code></pre>
<p>You can also extract specific files by running:</p>
<pre><code class="language-bash">sudo env &quot;PATH=$PATH&quot; borgmatic extract --archive host-2019-01-02T04:06:07.080910 --restore-path /path/1 /path/2</code></pre>
<p>More information about extracting repositories and individual files can be found here - <a href="https://torsion.org/borgmatic/docs/how-to/restore-a-backup/">https://torsion.org/borgmatic/docs/how-to/restore-a-backup/</a></p>
<p>Borg has many more great features you can read about in the official docs here - <a href="https://borgbackup.readthedocs.io/en/stable/">https://borgbackup.readthedocs.io/en/stable/</a></p>
<p>Hopefully this has given you a quick overview regarding Borg&#39;s features and how simple it can be to set up.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 7: Post Comments]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-7-post-comments</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-7-post-comments">
        </link>
        <updated>2019-03-29T10:21:20Z</updated>
        <summary type="html"><![CDATA[In this post we'll be looking at adding  a comment system for our blog posts in Cockpit. The system will allow comments on our blog posts, nested replies, comment moderation, basic spam protection and even markdown support!]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Parts 1, 2, 3, 4, 5 and 6 of this guide you can find them here:</p>
<ul>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment/">Part 3: Deployment</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-4-post-pagination">Part 4: Post Pagination</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-5-searching-posts/">Part 5: Searching Posts</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-6-contact-forms/">Part 6: Contact Forms</a></li>
</ul>
<h2 id="comment-sections-on-static-sites">Comment sections on static sites</h2>
<p>There are a number of different ways you can go about adding comments to your static site. The most common option is usually by using a third party service and embedding the comments onto your page using an iframe. Some examples are:</p>
<ul>
<li><a href="https://disqus.com/">Disqus</a></li>
<li><a href="https://www.spot.im/">Spot.IM</a></li>
<li><a href="https://just-comments.com">Just Comments</a></li>
</ul>
<p>There are also some pretty awesome self-hosted options like <a href="https://commento.io/">Commento</a> (the commenting platform I&#39;m using for this site).</p>
<h2 id="a-cockpit-comment-system">A Cockpit Comment System</h2>
<p>We&#39;re going to take advantage of Cockpit forms and use that as a basis for setting up comments on our blog. </p>
<p>Here&#39;s how it will work:</p>
<ol>
<li>Someone will fill out the comment form on our blog</li>
<li>This comment will be saved as a form entry in a form called comments</li>
<li>We will receive an email giving us the option to approve or view/delete the comment</li>
<li>If approved then our static site will be rebuilt to reflect the change and display the new comment</li>
</ol>
<p>There&#39;s quite a lot more going on than that but it should give a basic overview.</p>
<h2 id="starting-with-cockpit-on-the-backend">Starting With Cockpit on the Backend</h2>
<p>To get started we&#39;ll head over to Cockpit and create a new form called comments.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/05/5ca74eaf5db9dcockpit-comments-form.png" alt="Cockpit Comments Form"></p>
</div>

<p>Make sure you leave <code>save form data</code> as false, I&#39;ll explain why shortly.</p>
<p>You also need to set up SMTP mailer settings in your config if you have not done already. I explain how in my previous post on contact forms.</p>
<p>You should already have an API key you can use only for form submissions if you followed the last post in this series, if not create a new key and add this in the rules section <code>/api/forms/submit/*</code>.</p>
<p>Give it a test by sending a post request with Insomnia or Postman to see if your token is working as expected.</p>
<p>You should receive a notification email but you won&#39;t see a new form entry saved as we set this to false above.</p>
<p>This new comments form is where new comments will be posted to and saved when they are awaiting approval.</p>
<p>Once approved we will be deleting the entry from here, but more on that later.</p>
<h2 id="creating-a-new-comments-collection">Creating a New Comments Collection</h2>
<p>When we approve a comment we are going to save it as a new collection entry and remove its entry from the comments form.</p>
<p>This will allow us to create a collectionLink (relationship) between our post and the comments for that post.</p>
<p>That way when we fetch our posts data from Cockpit we can also fetch the comments belonging to each post at the same time.</p>
<p>So head over to Collections in Cockpit and click <code>Add Collection</code>.</p>
<p>Our new comments collection will have the following fields:</p>
<ul>
<li><strong>name</strong> (type text)</li>
<li><strong>email</strong> (type text)</li>
<li><strong>body</strong> (type markdown)</li>
<li><strong>notify_replies</strong> (type boolean) (options <code>{&quot;default&quot;: false}</code>)</li>
<li><strong>post</strong> (type collectionlink) - (options <code>{&quot;link&quot;: &quot;posts&quot;, &quot;display&quot;: &quot;title&quot;, &quot;multiple&quot;: false, &quot;limit&quot;: false}</code>)</li>
<li><strong>parent_id</strong> (type text)</li>
</ul>
<p>Make sure to include the options in the provided JSON options field when adding the notify_replies and post fields.</p>
<div class="blog-note">
    <b>Note:</b> You do not need to set the body as markdown if you don't want, you can simply choose textarea. We will need to santize the user markdown later on.
</div>  

<p>We set multiple to false in the post collectionLink, we&#39;ve essentially created the inverse of a one to many relationship. (In Laravel this would be like <code>return $this-&gt;belongsTo(&#39;App\Post&#39;);</code>)</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/05/5ca751fae052ccockpit-comments-collection.png" alt="Cockpit Comments Collection"></p>
</div>

<h2 id="updating-our-posts-collection">Updating Our Posts Collection</h2>
<p>If you&#39;ve been following along with this series you should already have a posts collection set up. If not I show you how in my first post of the series <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">here</a>.</p>
<p>We need to add a new collectionLink field called <code>comments</code> with the following options:</p>
<pre><code class="language-json">{
  &quot;link&quot;: &quot;comments&quot;,
  &quot;display&quot;: &quot;name&quot;,
  &quot;multiple&quot;: true,
  &quot;limit&quot;: false
}</code></pre>
<p>Notice here that we&#39;ve set multiple to true, this is essentially a one to many relationship. E.g. One post can have many comments. (In Laravel this would be like <code>return $this-&gt;hasMany(&#39;App\Comment&#39;);</code>)</p>
<p>Your posts collection should now look something like this:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/05/5ca755c8d2e51cockpit-posts-collection.png" alt="Cockpit Posts Collection"></p>
</div>

<p>Okay so we&#39;ve created a new comments form, a comments collection and updated our posts collection. Next we need to look at how we go about approving new comments that arrive in our comments form.</p>
<h2 id="approving-the-new-comment-with-a-custom-endpoint">Approving The New Comment With a Custom Endpoint</h2>
<p>When a new comment is made we need to be able to moderate it first before it is published to the site, that&#39;s why we keep all pending comments in our comments form first.</p>
<p>We&#39;re going to create a new custom endpoint in Cockpit that will allow us to simply click a link and approve a comment.</p>
<p>We first need to add a new custom API key that only has permission to approve comments. So head over to settings, API Access and add a new key with the following in the rules section <code>/api/forms/approve/comments</code>. We don&#39;t want to share this key with anyone.</p>
<p>To add a new custom api endpoint create a new file at <code>config/api/forms/approve/</code> called <code>comments.php</code> (you&#39;ll need to create the directories api, forms and approve) this will allow us to visit <code>https://cms.yourdomain.com/api/forms/approve/comments?id=xxxx&amp;token=xxxx</code> to access it.</p>
<p>We&#39;ll be passing an <code>id</code> parameter of the comments form entry to the endpoint which is why I&#39;ve included it in the url above.</p>
<p>In this file add the following:</p>
<pre><code class="language-php">&lt;?php
// find the form entry using its id we included in the url
$form_entry = cockpit(&#39;forms&#39;)-&gt;findOne(&#39;comments&#39;, [&#39;_id&#39; =&gt; $this-&gt;param(&#39;id&#39;, null)]);

if (!$form_data = $form_entry[&#39;data&#39;]) {
    return $this-&gt;stop(&#39;{&quot;error&quot;: &quot;No form entry found&quot;}&#39;, 412);
}

// find the post that this comment is for
$post = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;posts&#39;, [&#39;_id&#39; =&gt; $form_data[&#39;post_id&#39;]]);

if (!$post) {
    return $this-&gt;stop(&#39;{&quot;error&quot;: &quot;No post found&quot;}&#39;, 412);
}

// create a new comment in the comments collection with the form data and create collectionLink to the post
$comment_data = [
    &#39;parent_id&#39; =&gt; $form_data[&#39;parent_id&#39;],
    &#39;name&#39; =&gt; $form_data[&#39;name&#39;],
    &#39;email&#39; =&gt; $form_data[&#39;email&#39;],
    &#39;body&#39; =&gt; $form_data[&#39;comment&#39;],
    &#39;notify_replies&#39; =&gt; $form_data[&#39;notify_replies&#39;],
    &#39;post&#39; =&gt; [
        &#39;_id&#39; =&gt; $post[&#39;_id&#39;],
        &#39;link&#39; =&gt; &#39;posts&#39;,
        &#39;display&#39; =&gt; $post[&#39;title&#39;]
    ]
];

$comment = cockpit(&#39;collections&#39;)-&gt;save(&#39;comments&#39;, $comment_data);

// check if this is the first comment on the post, if so then $post[&#39;comments&#39;] will be an empty string so we update it to an empty array to prevent the next line throwing an error
if(!is_array($post[&#39;comments&#39;])){
    $post[&#39;comments&#39;] = [];
}

// also add a collectionLink from the post to the new comment
$post[&#39;comments&#39;][] = [
    &#39;_id&#39; =&gt; $comment[&#39;_id&#39;],
    &#39;link&#39; =&gt; &#39;comments&#39;,
    &#39;display&#39; =&gt; $comment[&#39;name&#39;]
];

$post = cockpit(&#39;collections&#39;)-&gt;save(&#39;posts&#39;, $post);

// delete the form entry from the comments form
cockpit(&#39;forms&#39;)-&gt;remove(&#39;comments&#39;, [&#39;_id&#39; =&gt; $form_entry[&#39;_id&#39;]]);

// redirect to view the comments collection
$this-&gt;reroute($this-&gt;baseUrl(&#39;/collections/entries/comments&#39;));</code></pre>
<p>I&#39;ve tried to add comments to the above code to explain what&#39;s going but what we basically do is first find the entry in the comments form by its id (we included it in the url id=xxx).</p>
<p>Then find the post that this pending comment belongs to. Then we save the new comment in the comments collection and create a collectionLink to the post.</p>
<p>We then update the post so that it also has a collectionLink to the new comment.</p>
<p>Finally we remove the form entry and redirect to the comments collection page.</p>
<h2 id="saving-the-form-entry">Saving The Form Entry</h2>
<p>We&#39;re going to need to access our approve comment form API key in the next file we create. To avoid hard coding it and potentially accidently committing it to version control we will create a <code>.env</code> file in our Cockpit root directory. Inside this <code>.env</code> file enter:</p>
<pre><code>APPROVE_TOKEN=xxxxxx
SITE_URL=https://cms.yourdomain.com</code></pre><p>Making sure to replace xxxx with your actual &quot;approve comment&quot; api key from above and <code>SITE_URL</code> with the url of your Cockpit site (no trailing slash).</p>
<p>Next create a new file in your Cockpit directory at config/bootstrap.php. Put the following inside:</p>
<pre><code class="language-php">&lt;?php
// save the form entry and add its _id to data
$app-&gt;on(&quot;forms.submit.before&quot;, function($form, &amp;$data, $frm, &amp;$options) use ($app) {

    if($form === &#39;comments&#39;){

        // make sure the comment has a valid post_id that exists
        if(isset($data[&#39;post_id&#39;]) &amp;&amp; $post = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;posts&#39;, [&#39;_id&#39; =&gt; $data[&#39;post_id&#39;]])){

            $data[&#39;post_title&#39;] = $post[&#39;title&#39;];

            $entry = cockpit(&#39;forms&#39;)-&gt;save($form, [&#39;data&#39; =&gt; $data]);

            $data[&#39;id&#39;] = $entry[&#39;_id&#39;];

        } else {
            $app-&gt;stop(&#39;{&quot;error&quot;: &quot;No post found&quot;}&#39;, 412);
        }
    }

});</code></pre>
<p>This is an event that we hook into before the form is submitted. We first make sure it is the correct form (in our case called comments) then we make sure that the form data we receive has the <code>post_id</code> set and that an actual post with that ID exists in our database.</p>
<p>If it does then we add <code>post_title</code> to the data and then save the submission as a new entry. That is why when we created the comments form above we made sure to set <code>save form data</code> as false, otherwise it would save the entry twice.</p>
<p>You might be wondering why I&#39;m saving the form entry now when it could have been saved anyway if we had just set <code>save form data</code> to true. The answer to that is because we need the <code>_id</code> of this entry so we can pass it through to our notification email and use it in our approve endpoint.</p>
<p>So after we save the entry we can retrieve its <code>_id</code> and add <code>$data[&#39;id&#39;]</code> to our data so we can use it in our email template along with our <code>SITE_URL</code> and <code>APPROVE_TOKEN</code> from our <code>.env</code> file.</p>
<h2 id="creating-a-custom-email-notification-template">Creating a Custom Email Notification Template</h2>
<p>In Cockpit you can create custom email templates to override the default one. To do this you simply create a new file at <code>config/forms/emails/</code> with the same name as the form you wish to override.</p>
<p>In our case we need to create one called <code>comments.php</code>, once created add the following:</p>
<pre><code class="language-php">@if( isset($data[&#39;post_title&#39;]) )
A new comment is awaiting approval on &lt;b&gt;{{ $data[&#39;post_title&#39;] }}&lt;/b&gt;
&lt;br&gt;&lt;br&gt;
@endif

@if( isset($data[&#39;name&#39;]) )
&lt;b&gt;Name:&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;{{ htmlspecialchars($data[&#39;name&#39;], ENT_QUOTES, &#39;UTF-8&#39;, true) }}
&lt;br&gt;
@endif

@if( isset($data[&#39;email&#39;]) )
&lt;br&gt;&lt;b&gt;Email:&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;{{ htmlspecialchars($data[&#39;email&#39;], ENT_QUOTES, &#39;UTF-8&#39;, true) }}
&lt;br&gt;
@endif

@if( isset($data[&#39;comment&#39;]) )
&lt;br&gt;&lt;b&gt;Comment:&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;{{ htmlspecialchars($data[&#39;comment&#39;], ENT_QUOTES, &#39;UTF-8&#39;, true) }}
&lt;br&gt;
@endif

@if( isset($data[&#39;id&#39;]) )
&lt;br&gt;
&lt;a href=&quot;{{ getenv(&#39;SITE_URL&#39;) }}/api/forms/approve/comments?id={{ $data[&#39;id&#39;] }}&amp;token={{ getenv(&#39;APPROVE_TOKEN&#39;) }}&quot;&gt;Click here to approve this comment&lt;/a&gt;
&lt;br&gt;&lt;br&gt;
or
&lt;br&gt;
@endif

&lt;br&gt;
&lt;a href=&quot;{{ getenv(&#39;SITE_URL&#39;) }}/forms/entries/comments&quot;&gt;View and delete it&lt;/a&gt;</code></pre>
<p>All we are doing here is using the data to create an email that will tell us who made the comment, the comment itself and allow us to click a link to approve the comment.</p>
<p>It is <strong>important</strong> to make sure you include <code>htmlspecialchars($var, ENT_QUOTES, &#39;UTF-8&#39;, true)</code> to protect ourselves against a comment containing malicious scripts etc.</p>
<h2 id="testing-the-template-and-approval">Testing The Template and Approval</h2>
<p>Now if you send a post request to submit the comments form with the correct data making sure you replace the <code>post_id</code> with the ID of one of your blog posts otherwise you won&#39;t be able to approve it. </p>
<pre><code class="language-json">{
    &quot;form&quot;: {
        &quot;post_id&quot;: &quot;xxxxxxxx&quot;,
        &quot;parent_id&quot;: null,
        &quot;name&quot;: &quot;John Doe&quot;,
        &quot;email&quot;: &quot;you@example.com&quot;,
        &quot;comment&quot;: &quot;This is my new comment.&quot;,
        &quot;notify_replies&quot;: true
    }
}</code></pre>
<p>Also make sure you use one of your real email addresses for email with notify replies set as true as we will be replying to this comment later.</p>
<p>You can find the ID of one of your blog posts by making a GET request to <code>/api/collections/get/posts?token=xxxx</code> where xxxx is your posts collection API key. Choose a post and then copy the <code>_id</code> value.</p>
<p>You should receive an email notification that uses the custom template above and includes our approve url.</p>
<p>You can click on the approve url and if successful it should redirect you to the comments collection where you can see the newly created comment.</p>
<p>You&#39;ll notice that the comment has the name of the blog post in the <code>post</code> column. This is because we set the value display as <code>title</code> in the JSON options for the collectionLink.</p>
<p>If you view your posts collection entries you&#39;ll see that the comments column has a <code>1</code> in it.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/06/5ca8743f3096bcockpit-post-comments.png" alt="Cockpit Post Comments"></p>
</div>

<p>So that means our post and comment are linked succesfully!</p>
<p>To see this in action you can make a POST request to <code>/api/collections/get/posts?token=xxx</code> with the body set as:</p>
<pre><code class="language-json">{&quot;sort&quot;:{&quot;_created&quot;:-1},&quot;populate&quot;:1}</code></pre>
<p>The <code>populate</code> option is important as it tells Cockpit to return and populate relationships 1 level deep. You should see in the response that each post has a <code>&quot;comments&quot;: []</code> array. If you find the blog post you added the comment to you should see the comment there.</p>
<p>If you set populate to <code>-1</code> it will populate to infinite levels, however it can cause some issues and errors. </p>
<p>Try setting populate to 0 or removing it and you&#39;ll notice that you won&#39;t get all fields returned for your comment.</p>
<h2 id="creating-a-new-custom-email-template-for-comment-replies">Creating a New Custom Email Template For Comment Replies</h2>
<p>Okay so we can now add a comment using our form and then approve the comment but how about comment replies and notifying the parent comment?</p>
<p>Well first off we need to create a new custom email template, so in <code>config/forms/emails</code> create a new file called <code>notify_reply.php</code> and add the following inside:</p>
<pre><code class="language-php">@if( isset($data[&#39;post_title&#39;]) )
Your comment has a new reply on &lt;b&gt;{{ $data[&#39;post_title&#39;] }}&lt;/b&gt;
&lt;br&gt;&lt;br&gt;
@endif

@if( isset($data[&#39;name&#39;]) )
&lt;b&gt;Name:&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;{{ htmlspecialchars($data[&#39;name&#39;], ENT_QUOTES, &#39;UTF-8&#39;, true) }}
&lt;br&gt;
@endif

@if( isset($data[&#39;comment&#39;]) )
&lt;br&gt;&lt;b&gt;Comment:&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;{{ htmlspecialchars($data[&#39;comment&#39;], ENT_QUOTES, &#39;UTF-8&#39;, true) }}
&lt;br&gt;
@endif

@if( $data[&#39;post_url&#39;] )
&lt;br&gt;
&lt;a href=&quot;{{ $data[&#39;post_url&#39;] }}&quot;&gt;Click here to view the comment&lt;/a&gt;
@endif</code></pre>
<p>Again be sure to <strong>include</strong> <code>htmlspecialchars()</code> here! We&#39;ll pass all this data through to this template when we actually come to send the email.</p>
<h2 id="notifying-the-parent-comment-of-new-replies">Notifying The Parent Comment of New Replies</h2>
<p>Now let&#39;s add the actual code that will send an email to the parent comment when it receives a reply and that reply is approved.</p>
<p>Just before we do open up your <code>.env</code> file and add the following:</p>
<pre><code>FRONTEND_URL=https://yourdomain.com</code></pre><p>Note that there is no trailing slash. We&#39;ll be using this to create the url for the blog post with its <code>title_slug</code> e.g. <code>https://yourdomain.com/first-blog-post</code>.</p>
<p>Open up <code>config/api/forms/approve/comments.php</code> and update the following just after we remove the form entry:</p>
<pre><code class="language-php">// check if the comment has a valid parent comment and that it exists
if(isset($comment[&#39;parent_id&#39;]) &amp;&amp; $parent_comment = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;comments&#39;, [&#39;_id&#39; =&gt; $comment[&#39;parent_id&#39;]])){

    // check if the parent comment has notify_replies set to true
    if($parent_comment[&#39;notify_replies&#39;]){

        // validate the email for the parent comment
        if($this-&gt;helper(&#39;utils&#39;)-&gt;isEmail($parent_comment[&#39;email&#39;])){

            // use our custom email template for a new reply notification
            if ($template = $this-&gt;path(&quot;#config:forms/emails/notify_reply.php&quot;)) {

                $notify_data = [
                    &#39;post_title&#39; =&gt; $post[&#39;title&#39;],
                    &#39;name&#39; =&gt; $comment[&#39;name&#39;],
                    &#39;comment&#39; =&gt; $comment[&#39;body&#39;],
                    &#39;post_url&#39; =&gt; getenv(&#39;FRONTEND_URL&#39;).&#39;/&#39;.$post[&#39;title_slug&#39;]
                ];

                $body = $this-&gt;renderer-&gt;file($template, [&#39;data&#39; =&gt; $notify_data], false);

                // send email to notify parent comment of a new reply
                try {
                    $response = $this-&gt;mailer-&gt;mail($parent_comment[&#39;email&#39;], &quot;New comment reply on: {$post[&#39;title&#39;]}&quot;, $body);
                } catch (\Exception $e) {
                    $response = $e-&gt;getMessage();
                }
            }
        }
    }
}

// display error if present or redirect to view the comments collection
return (isset($response) &amp;&amp; $response !== true) ? [&#39;error&#39; =&gt; $response] : $this-&gt;reroute($this-&gt;baseUrl(&#39;/collections/entries/comments&#39;));</code></pre>
<p>So what we&#39;re doing here is first checking to see if the comment has a <code>parent_id</code> value set, if it does and we find a comment with that ID in our database then check to see if the parent comment had <code>notify_replies</code> set to true.</p>
<p>If it does then we check if the parent comment&#39;s email is valid and if we have a custom template available called <code>notify_reply.php</code> (we do as we just created it).</p>
<p>Then we pass the data through to the template and attempt to send the email using our mailer.</p>
<h2 id="testing-the-comment-reply-notification">Testing The Comment Reply Notification</h2>
<p>If you used one of your real email addresses and set <code>notify_replies</code> to true when testing the comment approval above then we can now try and reply to this comment.</p>
<p>So first we need to find out the ID for the comment we would like to reply to, to do this you can make a GET request like above to your posts collection endpoint and find the post with the comment, then copy the ID for the comment.</p>
<p>Now we can make another form submission with the following data:</p>
<pre><code class="language-json">{
    &quot;form&quot;: {
        &quot;post_id&quot;: &quot;xxxxxxxx&quot;,
        &quot;parent_id&quot;: &quot;xxxxxx&quot;,
        &quot;name&quot;: &quot;Jane Doe&quot;,
        &quot;email&quot;: &quot;you@example.com&quot;,
        &quot;comment&quot;: &quot;This is a reply to my first comment.&quot;,
        &quot;notify_replies&quot;: true
    }
}</code></pre>
<p>Making sure to use the same <code>post_id</code> as before and the <code>parent_id</code> as the ID we just copied from the first comment.</p>
<p>You should receive the email notification to confirm or view/delete the comment entry. Once you click approve you should then receive an email to the parent comment&#39;s email address letting you know your comment has a new reply.</p>
<h2 id="server-side-validation">Server Side Validation</h2>
<p>Let&#39;s finish up the backend by adding some server side validation for our comments form.</p>
<p>If you&#39;ve read the previous post about contact forms you&#39;ll know how to do this. Create a new file at <code>config/forms/</code> called <code>comments.php</code> (it must have the same name as the one we gave our form).</p>
<pre><code class="language-php">&lt;?php

// honeypot field
if (isset($data[&#39;website&#39;])) {

    // you can save the submission in case it is actually a genuine one like we did in the last blog post on contact forms, make sure you have a form set up called bots
    cockpit(&#39;forms&#39;)-&gt;save(&#39;bots&#39;, [&#39;data&#39; =&gt; $data]);

    return false;
}

if (empty($data[&#39;post_id&#39;])) {
    return false;
}

if (empty($data[&#39;name&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The name field is required&#39;], 200);
}

if (!filter_var($data[&#39;email&#39;], FILTER_VALIDATE_EMAIL)) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;A valid email is required&#39;], 200);
}

if (empty($data[&#39;comment&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The comment field is required&#39;], 200);
}

if (!is_bool($data[&#39;notify_replies&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;Notify replies must be of type boolean&#39;], 200);
}

return true;</code></pre>
<p>So we simply validate our comment form fields, we&#39;re going to use <code>website</code> as a honeypot field to catch bots like we did in the previous post. If the spam bot accidentally automatically fills in the website field we will return false.</p>
<p>So I think we&#39;ve finished up setting the Cockpit side of the comment system up, let&#39;s now look at the Nuxt frontend. </p>
<h2 id="updating-our-nuxt-env-and-config">Updating Our Nuxt .env and Config</h2>
<p>Moving on to Nuxt.js and our frontend let&#39;s first update our Nuxt .env file and add our <code>FORMS_TOKEN</code>. If you&#39;ve followed the previous post you should already have this.</p>
<p>Next open up nuxt.config.js and in the env property add:</p>
<pre><code class="language-javascript">env: {
  commentUrl: `${process.env.BASE_URL}/api/forms/submit/comments?token=${process.env.FORMS_TOKEN}`
},</code></pre>
<p>This is the endpoint we&#39;ll be posting our comments to. </p>
<div class="blog-note">
    <b>Note:</b> Anything we add to env in nuxt.config.js will be bundled up and public in our js files
</div>  

<p>So make sure not to include any sensitive API keys here. We obviously need the form endpoint and token to be public otherwise we won&#39;t be able to submit new comments from the frontend.</p>
<h2 id="updating-the-blog-post-page">Updating The Blog Post Page</h2>
<p>Open up your <code>_title_slug.vue</code> page (the individual blog page) and update it to resemble the following:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;article class=&quot;my-8&quot;&gt;
      &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
        {{ post._created | toDate }}
        &lt;a v-for=&quot;(tag, key) in post.tags&quot; :key=&quot;key&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
      &lt;/div&gt;
      &lt;h1 class=&quot;mt-2&quot;&gt;
        {{ post.title }}
      &lt;/h1&gt;
      &lt;div class=&quot;mt-4 markdown&quot; v-html=&quot;$options.filters.parseMd(post.excerpt + &#39;\n&#39; + post.content)&quot;&gt;
      &lt;/div&gt;

      &lt;div id=&quot;comments&quot; class=&quot;mt-8 mb-4 pt-3 border-t-2&quot;&gt;
        &lt;h2 class=&quot;mb-2&quot;&gt;
          Comments
        &lt;/h2&gt;
        &lt;comment-form class=&quot;border-b-2&quot; :post_id=&quot;post._id&quot;/&gt;
      &lt;/div&gt;

      &lt;ul&gt;
        &lt;comment
        v-for=&quot;comment in comments&quot;
        :key=&quot;comment._id&quot;
        :post_id=&quot;post._id&quot;
        :all=&quot;post.comments&quot;
        :comment=&quot;comment&quot;
        /&gt;
      &lt;/ul&gt;
    &lt;/article&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import CommentForm from &#39;~/components/CommentForm.vue&#39;
import Comment from &#39;~/components/Comment.vue&#39;

export default {
  async asyncData ({ app, params, error, payload }) {
    if (payload) {
      return { post: payload }
    } else {
      let { data } = await app.$axios.post(process.env.POSTS_URL,
      JSON.stringify({
          filter: { published: true, title_slug: params.title_slug },
          sort: {_created:-1},
          populate: 1
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })

      if (!data.entries) {
        return error({ message: &#39;404 Page not found&#39;, statusCode: 404 })
      }

      return { post: data.entries[0] }
    }
  },

  components: {
    CommentForm,
    Comment
  },

  head () {
    return {
      title: this.post.title,
      meta: [
        { hid: &#39;description&#39;, name: &#39;description&#39;, content: this.post.excerpt },
      ]
    }
  },

  computed: {
    comments: function () {
      return this.post.comments ? this.post.comments.filter(comment =&gt; !comment.parent_id) : []
    }
  }
}
&lt;/script&gt;</code></pre>
<p>There are a few things to note here. We&#39;ve got a <code>CommentForm</code> and a <code>Comment</code> component that we are yet to make. We pass the <code>comment-form</code> the current post ID as a prop. We loop over each comment and pass the <code>comment</code> component the post ID, all the comments for the post and the comment itself.</p>
<p>In the script section we register the Comment and CommentForm components.</p>
<p>We then have a computed property <code>comments</code> this simply returns all comments for our post that do not have a <code>parent_id</code> set e.g. they are top level comments.</p>
<p>At first I had comments set up with a collectionLink relationship to themselves so comments could have children and a parent. However I ran into issues whilst fetching the data relating to <code>populate</code> in the request and the depth it should be carried out to. For example if setting <code>populate: -1</code> in the request it would cause timeout errors for me.</p>
<p>So I decided instead to keep it simple and just add a parent_id to any child comment that references the ID of its parent.</p>
<p>That way I can organise the comments correctly in Nuxt by filtering only the parent comments and then recursively finding their children if they have any.</p>
<h2 id="the-comment-form-component">The Comment Form Component</h2>
<p>In your components directory create a new file called <code>CommentForm.vue</code> and add the following inside:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;form @submit=&quot;checkForm&quot; method=&quot;post&quot; :id=&quot;parent_id ? `reply-${parent_id}` : &#39;&#39;&quot;&gt;
    &lt;div class=&quot;flex flex-col md:flex-row mb-4&quot;&gt;
    &lt;div class=&quot;w-full md:w-1/2 md:mr-2&quot;&gt;
      &lt;input v-model=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;Your Name&quot; class=&quot;block bg-gray-200 mt-2 rounded w-full py-2 px-3&quot;&gt;
    &lt;/div&gt;
    &lt;div class=&quot;w-full md:w-1/2 md:ml-2&quot;&gt;
      &lt;input v-model=&quot;email&quot; type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Your Email&quot; class=&quot;block bg-gray-200 mt-2 rounded w-full py-2 px-3&quot;&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;mb-4&quot;&gt;
      &lt;textarea v-model=&quot;comment&quot; name=&quot;comment&quot; rows=&quot;6&quot; :placeholder=&quot;parent_id ? `Reply to ${parent_name}...` : &#39;Add a comment&#39;&quot; class=&quot;bg-gray-200 rounded resize-none w-full h-20 py-2 px-3&quot;&gt;
      &lt;/textarea&gt;
    &lt;/div&gt;
    &lt;div class=&quot;mb-4&quot;&gt;
      &lt;input v-model=&quot;notify_replies&quot; class=&quot;mr-2&quot; type=&quot;checkbox&quot;&gt;
      &lt;span class=&quot;text-sm&quot;&gt;
        Notify me when anyone replies
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;input type=&quot;text&quot; name=&quot;website&quot; v-model=&quot;website&quot; class=&quot;hidden opacity-0 z-0&quot; tabindex=&quot;-1&quot; autocomplete=&quot;off&quot;&gt;
    &lt;div class=&quot;mb-4&quot;&gt;
      &lt;input type=&quot;submit&quot; value=&quot;Add Comment&quot; :class=&quot;{ &#39;cursor-not-allowed opacity-50&#39;: loading }&quot; class=&quot;cursor-pointer bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-600 hover:border-blue-500 rounded&quot;&gt;
    &lt;/div&gt;
    &lt;div v-if=&quot;errors.length&quot; class=&quot;mb-4 text-red-500&quot;&gt;
      &lt;b&gt;Please correct the following error(s):&lt;/b&gt;
      &lt;ul&gt;
        &lt;li v-for=&quot;error in errors&quot; :key=&quot;error&quot;&gt;
          {{ error }}
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div v-if=&quot;success&quot; class=&quot;text-green-500 mb-4&quot;&gt;
      &lt;b&gt;Your comment is currently awaiting moderation&lt;/b&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import axios from &#39;axios&#39;

export default {
  name: &quot;commentForm&quot;,
  props: {
    post_id: String,
    parent_id: String,
    parent_name: String
  },

  data: function () {
    return {
      errors: [],
      name: null,
      email: null,
      comment: null,
      notify_replies: false,
      website: null,
      loading: false,
      success: false
    }
  },

  methods: {
    checkForm: function (e) {
      this.errors = []
      this.success = false

      if (!this.name) {
        this.errors.push(&quot;Name required&quot;)
      }
      if (!this.email) {
        this.errors.push(&#39;Email required&#39;)
      } else if (!this.validEmail(this.email)) {
        this.errors.push(&#39;Valid email required&#39;)
      }
      if (!this.comment) {
        this.errors.push(&quot;Comment required&quot;)
      }

      if (!this.errors.length) {
        this.submitForm()
      }

      e.preventDefault()
    },

    submitForm: function () {
      this.loading = true

      axios.post(process.env.commentUrl,
      JSON.stringify({
          form: {
            post_id: this.post_id,
            parent_id: this.parent_id,
            name: this.name,
            email: this.email,
            comment: this.comment,
            notify_replies: this.notify_replies,
            website: this.website //honeypot field
          }
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })
      .then(({ data }) =&gt; {
        this.loading = false

        if(data.error){
          this.errors.push(data.error)
        } else if(data.name &amp;&amp; data.email &amp;&amp; data.comment) {
          this.name = this.email = this.comment = null
          this.success = true
        }
      }).catch(error =&gt; {
        this.loading = false

        this.errors.push(&#39;An error occured, please try again later&#39;)
      })
    },

    validEmail: function (email) {
      let re = /^(([^&lt;&gt;()\[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()\[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
      return re.test(email)
    }
  }
}
&lt;/script&gt;</code></pre>
<p>The first thing to note is that this form is very similar to the contact form we did in the previous post.</p>
<p>If the component has a <code>parent_id</code> prop passed to it then we add an id to the form, you&#39;ll see why later. We also check for <code>parent_id</code> whilst setting the placeholder for the comment textarea, if there is a parent we reference the parent&#39;s name.</p>
<p>We need to import axios here as we&#39;re now calling it on the client side so can&#39;t use <code>app.$axios</code> as when in the <code>asyncData</code> function.</p>
<p>The form has some simple client side validation like our comment form and also the same  honeypot field called website.</p>
<p>If the form submission has any errors we display them and if it&#39;s successful we display a success message.</p>
<h2 id="the-recursive-comment-component">The Recursive Comment Component</h2>
<p>Now onto the Comment component, create a new file in the components directory called <code>Comment.vue</code> and add the following:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;li class=&quot;mb-4&quot; :class=&quot;!parent ? &#39;border-b-2&#39; : &#39;&#39;&quot;&gt;
    &lt;div ref=&quot;parent&quot;&gt;
      &lt;div class=&quot;text-gray-600 text-sm mb-2&quot;&gt;
        &lt;span class=&quot;text-gray-800 font-semibold&quot;&gt;
          {{comment.name}}
        &lt;/span&gt;
        &lt;span class=&quot;mx-1 text-xs&quot;&gt;•&lt;/span&gt;
        {{ comment._created | toDate }}
        &lt;span v-if=&quot;parent&quot;&gt;
          &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;-5 -5 24 24&quot; width=&quot;12&quot; height=&quot;12&quot; preserveAspectRatio=&quot;xMinYMin&quot; class=&quot;inline-block text-gray-600 fill-current&quot;&gt;
            &lt;path d=&quot;M10.586 5.657l-3.95-3.95A1 1 0 0 1 8.05.293l5.657 5.657a.997.997 0 0 1 0 1.414L8.05 13.021a1 1 0 1 1-1.414-1.414l3.95-3.95H1a1 1 0 1 1 0-2h9.586z&quot;&gt;&lt;/path&gt;
          &lt;/svg&gt;
          {{ parent.name }}
        &lt;/span&gt;
      &lt;/div&gt;

      &lt;div class=&quot;comment text-gray-800 text-base&quot; v-html=&quot;$options.filters.parseMd(comment.body)&quot;&gt;&lt;/div&gt;

      &lt;div class=&quot;text-gray-600 text-sm mt-2 mb-4 cursor-pointer&quot; @click=&quot;toggleReply&quot;&gt;
        &lt;span v-if=&quot;replyOpen&quot;&gt;Cancel&lt;/span&gt;
        &lt;span v-else&gt;Reply&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;ul class=&quot;ml-10 comment-list&quot; v-if=&quot;children(comment._id).length&quot;&gt;
      &lt;comment
      v-for=&quot;child in children(comment._id)&quot;
      :key=&quot;child._id&quot;
      :post_id=&quot;post_id&quot;
      :all=&quot;all&quot;
      :comment=&quot;child&quot;
      :parent=&quot;comment&quot;
      /&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import Vue from &#39;vue&#39;
import CommentForm from &#39;~/components/CommentForm.vue&#39;

export default {
  name: &quot;comment&quot;,
  props: {
    post_id: String,
    all: Array,
    comment: Object,
    parent: Object
  },

  data: function () {
    return {
      replyOpen: false
    }
  },

  methods: {
    children: function (parent_id) {
      return this.all.filter(comment =&gt; comment.parent_id === parent_id)
    },

    toggleReply: function () {
      if(!this.replyOpen){
        let ComponentClass = Vue.extend(CommentForm)
        let instance = new ComponentClass({
            propsData: {
              post_id: this.post_id,
              parent_id: this.comment._id,
              parent_name: this.comment.name
            }
        })
        instance.$mount()
        this.$refs.parent.appendChild(instance.$el)

        this.replyOpen = true
      } else {
        // remove the reply form from the DOM
        let form = document.getElementById(`reply-${this.comment._id}`)

        if(form){
          this.$refs.parent.removeChild(form)

          this.replyOpen = false
        }
      }
    }
  }
}
&lt;/script&gt;</code></pre>
<p>This component is a little more complex than the CommentForm one. At the top in the <code>li</code> tag we check if the comment has a parent. If it doesn&#39;t then we add a border to the bottom, just to add some separation between top level comments.</p>
<p>We then display the comment author&#39;s name, the date it was made (approved in our case) and the body of the comment. </p>
<p>We will be sanitizing the comment body shortly as it is not safe to use v-html on unsanitized user inputted data. A malicious actor could easily include javascript code on our site. </p>
<div class="blog-note">
    <b>Warning:</b> We are using v-html and parsing user inputted data here in the comment body. This is inherently unsafe, never do this without first sanitizing the data to prevent XSS attacks. We will sanitize in the next step.
</div>

<p>If earlier in this post when you set up the comments collection you chose not to support markdown and set the comment body field type as a textarea then you do not need to pass the <code>comment.body</code> through v-html or <code>$options.filters.parseMd()</code>.</p>
<p>We then have a div with <code>Reply</code> or <code>Cancel</code> depending on whether someone has clicked and opended a new comment form for that particular comment.</p>
<p>Finally we have a section for any child comments, hence this being a recursive component. We include the component again inside itself if the current comment has any children.</p>
<p>We loop over the comment&#39;s children and pass through the necessary props, again passing down the <code>all</code> posts variable, the <code>post_id</code> and the <code>parent</code> comment.</p>
<p>The method we have called children simply filters the <code>all</code> comments prop and returns any comments that have the current comment&#39;s ID set as their <code>parent_id</code>.</p>
<p>Now for the intersting part, handling comment replies. I needed a way to make sure the <code>parent_id</code> value was passed to the comment form if we were replying to a comment, that way we can identify which comment the reply belongs to.</p>
<p>You may have noticed that we imported <code>Vue</code> and <code>CommentForm</code>, this is so we can use them in the <code>toggleReply</code> method. In this method we first check to see if the <code>replyOpen</code> variable is set to false (e.g. the reply form is not active). </p>
<p>We then use <a href="https://vuejs.org/v2/api/#Vue-extend">Vue.extend</a> to create a &quot;subclass&quot; of the base Vue constructor, passing in our CommentForm component. Next we create a new instance of this class and pass it the relevant props, including the <code>parent_id</code> which is the ID of the current comment. Then we mount this without passing through any mount point.</p>
<p>The reason we do not pass any mount point is because we want to insert it into the DOM ourselves. The Vue docs state that:</p>
<blockquote>
<p>If elementOrSelector argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>
</blockquote>
<p>So now we can insert this template by calling <code>this.$refs.parent.appendChild(instance.$el)</code> where <code>parent</code> is a reference we added to a div at the top of the comment component like so <code>ref=&quot;parent&quot;</code>.</p>
<p>Now when we click on <code>Reply</code> the toggleReply function will be called and it will append a new instance of our CommentForm component to the end of this div.</p>
<p>If <code>replyOpen</code> is set to true then <code>Cancel</code> will be displayed instead of <code>Reply</code> and we will run the else portion of <code>toggleReply</code>. Here we simply find the comment form by id <code>reply-${this.comment._id}</code> and call again the parent reference using it to remove the comment form from the DOM and set replyOpen back to false.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/09/5cac81a3e803dstatic-blog-comment-reply.png" alt="Static Blog Comment Reply"></p>
</div>

<h2 id="sanitizing-the-markdown">Sanitizing The Markdown</h2>
<p>As I mentioned above you cannot simply pass user inputted data through v-html as it will be rendered as actual html on the page. So if a user made a comment with this content:</p>
<pre><code class="language-html">&lt;script&gt;alert(&#39;Hello&#39;);&lt;/script&gt;</code></pre>
<p>And we approved it, then whenever anybody visited the blog post with that comment on they would get an alert popup! You can read more about XSS attacks <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">here</a>.</p>
<p>To prevent against this we could either not run any user input through v-html (but then our markdown support wouldn&#39;t work) or first sanitize the data before displaying it on the page.</p>
<p>I tried a few different html sanitzers and in the end settled on <a href="https://github.com/punkave/sanitize-html">Sanitize HTML</a>.</p>
<p>Open up the terminal in your Nuxt root and run:</p>
<pre><code class="language-bash">npm install sanitize-html --save-dev</code></pre>
<p>Now that we&#39;ve got it installed we need to use it, so open your filters.js file inside the plugins directory. Add the following to the top of the file:</p>
<pre><code class="language-javascript">const sanitizeHtml = require(&#39;sanitize-html&#39;)</code></pre>
<p>and then update the <code>parseMd</code> filter:</p>
<pre><code class="language-javascript">Vue.filter(&#39;parseMd&#39;, function(content) {
  let clean = sanitizeHtml(content)

  return marked(clean)
})</code></pre>
<p>So all we&#39;re doing here is first passing through the content to <code>sanitizeHtml</code> and then passing the cleaned content to <code>marked</code> to parse the markdown.</p>
<div class="blog-note">
    <b>Warning:</b> I have not tested this for all edge cases and cannot guarantee it is 100% safe in all occasions. Use in production at your own risk.
</div>  

<p>If you want to test your sanitization is working as it should be try posting a comment with the content from this <a href="https://github.com/ismailtasdelen/xss-payload-list">xss-payload-list</a>. </p>
<p>SanitzeHtml seems to cope with this XSS payload well and mitigates all attempted attacks.</p>
<h2 id="adding-a-little-styling">Adding a Little Styling</h2>
<p>Let&#39;s add a tiny bit of css for our comments, so update your main.css to the following:</p>
<pre><code class="language-css">@tailwind base;

@tailwind components;

a {
  @apply text-blue-400;
}

.content {
  width: 50rem;
}

.markdown p {
  @apply mt-0 mb-6;
}

.markdown ul {
  @apply mb-6;
}

.markdown pre {
  @apply my-8;
}

.comment {
  @apply whitespace-pre-wrap;
}

.comment p {
  @apply mb-4 inline-block;
}

.comment p:last-of-type {
  @apply mb-0;
}

.comment pre {
  @apply my-4;
}

.comment pre:last-of-type {
  @apply mb-0;
}

.comment p:last-child {
  @apply mb-0;
}

/* purgecss start ignore */
table {
  @apply overflow-auto w-full;
}

table tr {
  @apply bg-white border-t border-gray-400;
}

table th, table td {
  @apply border border-gray-400 py-2 px-4;
}

.search-results em {
  @apply not-italic bg-blue-200;
}
/* purgecss end ignore */

@tailwind utilities;</code></pre>
<p>The whitespace-pre-wrap will help make sure the comments display correctly on the page.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/09/5cac8cd2eaa9bstatic-blog-comments.png" alt="Static Blog Comments"></p>
</div>

<h2 id="adding-hooks-in-cockpit-for-when-deleting-comments-or-a-post">Adding Hooks in Cockpit For When Deleting Comments or a Post</h2>
<p>With our collectionLink between a post and its comments if you delete a comment we would like the deleted comment to be &quot;unlinked&quot; from the post.</p>
<p>This doesn&#39;t seem to happen by default so we need to add a <code>collections.remove.before.comments</code> hook to do it for us.</p>
<p>So in <code>config/bootstrap.php</code> add the following code:</p>
<pre><code class="language-php">$app-&gt;on(&quot;collections.remove.before.comments&quot;, function($name, &amp;$criteria) use ($app) {

    // find the comment using its id
    $comment = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;comments&#39;, [&#39;_id&#39; =&gt; $criteria[&#39;_id&#39;]]);

    if(isset($comment[&#39;post&#39;][&#39;_id&#39;])){

        // find the post it is currently linked to
        $post = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;posts&#39;, [&#39;_id&#39; =&gt; $comment[&#39;post&#39;][&#39;_id&#39;]]);

        if(isset($post[&#39;comments&#39;]) &amp;&amp; is_array($post[&#39;comments&#39;])){

            $comment_ids = array_column($post[&#39;comments&#39;], &#39;_id&#39;);

            $key = array_search($comment[&#39;_id&#39;], $comment_ids);

            unset($post[&#39;comments&#39;][$key]);

            cockpit(&#39;collections&#39;)-&gt;save(&#39;posts&#39;, $post);
        }
    }
});</code></pre>
<p>All we are doing here is finding the comment we&#39;re about to delete, then finding the post it belongs to and removing the link by unsetting the corresponding array item in the <code>$post[&#39;comments&#39;]</code> array.</p>
<p>Now we can also do the reverse, e.g. unlink all comments (or just delete them if we want) for a post when the post is deleted.</p>
<p>So add the following below the above:</p>
<pre><code class="language-php">$app-&gt;on(&quot;collections.remove.before.posts&quot;, function($name, &amp;$criteria) use ($app) {

    // find the post using its id
    $post = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;posts&#39;, [&#39;_id&#39; =&gt; $criteria[&#39;_id&#39;]]);

    if(isset($post[&#39;comments&#39;]) &amp;&amp; is_array($post[&#39;comments&#39;])){

        // loop over each linked comment
        foreach($post[&#39;comments&#39;] as $item){

            $comment = cockpit(&#39;collections&#39;)-&gt;findOne(&#39;comments&#39;, [&#39;_id&#39; =&gt; $item[&#39;_id&#39;]]);

            // set the post to an empty string
            $comment[&#39;post&#39;] = &quot;&quot;;

            cockpit(&#39;collections&#39;)-&gt;save(&#39;comments&#39;, $comment);
        }
    }
});</code></pre>
<p>Now this will simply unlink the comments but not delete them, if you&#39;d like to just delete them update the loop to this:</p>
<pre><code class="language-php">// loop over each linked comment
foreach($post[&#39;comments&#39;] as $item){

    // delete each linked comment
    cockpit(&#39;collections&#39;)-&gt;remove(&#39;comments&#39;, [&#39;_id&#39; =&gt; $item[&#39;_id&#39;]]);
}</code></pre>
<h2 id="adding-comment-count-to-posts">Adding Comment Count to Posts</h2>
<p>To add a little comment count to the top of each post you can edit a small part of the following files - <code>index.vue</code>, <code>_page.vue</code> and <code>_tag.vue</code> to the following:</p>
<pre><code class="language-html">&lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
  {{ post._created | toDate }}
  &lt;span class=&quot;ml-1 text-xs&quot;&gt;•&lt;/span&gt;
  &lt;a v-for=&quot;tag in post.tags&quot; :key=&quot;tag&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;#{{ tag }}&lt;/a&gt;
  &lt;span class=&quot;mx-1 text-xs&quot;&gt;•&lt;/span&gt;
  &lt;span&gt;
    {{ post.comments ? post.comments.length : 0 }}
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;-2 -2 24 24&quot; width=&quot;12&quot; height=&quot;12&quot; preserveAspectRatio=&quot;xMinYMin&quot; class=&quot;inline-block text-gray-600 fill-current&quot;&gt;
      &lt;path d=&quot;M3 .565h14a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3h-6.958l-6.444 4.808A1 1 0 0 1 2 18.57v-4.006a2 2 0 0 1-2-2v-9a3 3 0 0 1 3-3z&quot;&gt;&lt;/path&gt;
    &lt;/svg&gt;
  &lt;/span&gt;
&lt;/div&gt;</code></pre>
<p>and then in <code>_title_slug.vue</code> to this so we can click the comment count and be taken straight to the comment section:</p>
<pre><code class="language-html">&lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
  {{ post._created | toDate }}
  &lt;span class=&quot;ml-1 text-xs&quot;&gt;•&lt;/span&gt;
  &lt;a v-for=&quot;tag in post.tags&quot; :key=&quot;tag&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;#{{ tag }}&lt;/a&gt;
  &lt;span class=&quot;mx-1 text-xs&quot;&gt;•&lt;/span&gt;
  &lt;a href=&quot;#comments&quot; class=&quot;text-gray-600&quot;&gt;
    {{ post.comments ? post.comments.length : 0 }}
    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;-2 -2 24 24&quot; width=&quot;12&quot; height=&quot;12&quot; preserveAspectRatio=&quot;xMinYMin&quot; class=&quot;inline-block text-gray-600 fill-current&quot;&gt;
      &lt;path d=&quot;M3 .565h14a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3h-6.958l-6.444 4.808A1 1 0 0 1 2 18.57v-4.006a2 2 0 0 1-2-2v-9a3 3 0 0 1 3-3z&quot;&gt;&lt;/path&gt;
    &lt;/svg&gt;
  &lt;/a&gt;
&lt;/div&gt;</code></pre>
<p>It should now look a little like this.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/09/5caccbcc5a5f2static-blog-comment-count.png" alt="Static Blog Comment Count"></p>
</div>

<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>This is only a basic example of a comment system and it could definitely be greatly improved but hopefully it gives you some ideas on what you can do with Cockpit.</p>
<p>Now whenever a new comment is approved Cockpit will automatically fire our rebuild webhook from <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment">part 3</a> of this series and run <code>npm run generate</code> again for our site!</p>
<p>If you notice any problems or can think of any improvements for this post feel free to add a comment or open an issue on Github.</p>
<p>You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here.</a></p>
<p>Also I&#39;ve just launched a live demo of this site on Netlify - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 6: Contact Forms]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-6-contact-forms</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-6-contact-forms">
        </link>
        <updated>2019-03-07T13:11:28Z</updated>
        <summary type="html"><![CDATA[In this post of our Nuxt Cockpit Static Blog series we'll be looking at how to add a basic contact form to our static site so we can receive enquiries from users. The form will have both client and server side validation. We'll also take a look at some basic spam protection measures we can add.]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Parts 1, 2, 3, 4 and 5 of this guide you can find them here:</p>
<ul>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment/">Part 3: Deployment</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-4-post-pagination">Part 4: Post Pagination</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-5-searching-posts/">Part 5: Searching Posts</a></li>
</ul>
<h2 id="handling-forms-on-static-sites">Handling Forms on Static Sites</h2>
<p>There are a number of different ways you can go about handling forms on static sites, including:</p>
<ul>
<li>Netlify</li>
<li>Google Forms</li>
<li>Formspree</li>
<li>99 Inbound</li>
</ul>
<p>Cockpit comes with its own solution that can help us add forms to our site using simple API POST requests to handle submissions.</p>
<p>Submissions made through the API can be viewed in the Cockpit dashboard and also notify you via email when a new submission is made.</p>
<p>You can read more about Cockpit forms in the documentation <a href="https://getcockpit.com/documentation/modules/forms">here</a>.</p>
<h2 id="adding-a-new-api-token">Adding a New API Token</h2>
<p>First things first we need to generate a new API token in Cockpit and also make sure it only has permissions to hit the forms endpoint.</p>
<p>So head over to Cockpit and go to Settings then API Access. Click the little plus icon to add a new key and add the following to the rules field: <code>/api/forms/submit/*</code>.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/03/07/5c812728321e5cockpit-forms-api-key.png" alt="Cockpit Forms API Key"></p>
</div>

<p>Now this key will only be able to perform form submissions.</p>
<h2 id="creating-a-new-form-in-cockpit">Creating a New Form in Cockpit</h2>
<p>In order for Cockpit to handle submissions we first need to create a new form. So from the dashboard click on forms and then click &#39;Create one&#39;.</p>
<p>Give it a name like <code>contact</code> and a label of <code>Contact Form</code>. Add your email if you wish to be notified when new submissions are made. Turn on &#39;Save form data&#39; if you would like to be able to view submission entries from Cockpit.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/03/07/5c81295621249cockpit-contact-form.png" alt="Cockpit Contact Form"></p>
</div>

<p>Now that we&#39;ve created our contact form in Cockpit we can test it by sending a POST request to the right endpoint.</p>
<h2 id="updating-cockpit-mailer-config">Updating Cockpit Mailer Config</h2>
<p>Before we can test out our form we need to update our Mailer config and add some SMTP details. Go to settings and then click on settings and add SMTP details for the email address you&#39;d like to use.</p>
<blockquote>
<p>If you didn&#39;t enter an email when creating the form above you can skip adding SMTP details</p>
</blockquote>
<p>Add the following inside config.yaml</p>
<pre><code class="language-yaml"># use smtp to send emails
mailer:
    from      : you@example.com
    transport : smtp
    host      : smtp.myhost.tld
    user      : you@example.com
    password  : yourpassword
    port      : 587
    auth      : true
    encryption: tls # &#39;&#39;, &#39;ssl&#39; or &#39;tls&#39;</code></pre>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/03/07/5c812ddc7fdc3cockpit-mailer-config.png" alt="Cockpit Mailer Config"></p>
</div>

<h2 id="testing-our-contact-form">Testing Our Contact Form</h2>
<p>If you have <a href="https://www.getpostman.com/">Postman</a> or <a href="https://insomnia.rest/">Insomnia</a> installed you can easily send a POST request to your Cockpit endpoint.</p>
<p>The endpoint we need to use is <code>cms.yourdomain.com/api/forms/submit/contact?token=xxx</code> where token is the API Key we created above to use for our form.</p>
<p>Make sure to set a header with Content-Type as <code>application/json</code> and then set the request body as the following JSON:</p>
<pre><code class="language-json">{
    &quot;form&quot;: {
        &quot;name&quot;:&quot;John Doe&quot;,
        &quot;email&quot;:&quot;johndoe@example.com&quot;,
        &quot;message&quot;: &quot;This is the message body!&quot;
    }
}</code></pre>
<p>The response returned if all was successful should just be the new form entry:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;email&quot;: &quot;johndoe@example.com&quot;,
  &quot;message&quot;: &quot;This is the message body!&quot;
}</code></pre>
<p>If an error occurred (e.g. forgetting to update config.yaml) then the response will look something like this:</p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;Invalid address:  (From): root@localhost&quot;,
  &quot;data&quot;: {
    &quot;name&quot;: &quot;John Doe&quot;,
    &quot;email&quot;: &quot;johndoe@example.com&quot;,
    &quot;message&quot;: &quot;This is the message body!&quot;
  }
}</code></pre>
<p>If you head to <code>cms.yourdomain.com/forms/entries/contact</code> you should now see the entry we just submitted via the API. You should also have received an email with the form submission details.</p>
<h2 id="updating-our-blogs-environment-variables">Updating Our Blogs Environment Variables</h2>
<p>Open up your .env file for Nuxt and add a new variable called FORMS_TOKEN.</p>
<pre><code>FORMS_TOKEN=xxxxxxxxxxxxxx</code></pre><p>Now we also need to update the env property in our nuxt.config.js. Add the following anywhere inside module.exports = { ... }</p>
<pre><code class="language-javascript">env: {
  contactUrl: `${process.env.BASE_URL}/api/forms/submit/contact?token=${process.env.FORMS_TOKEN}`
},</code></pre>
<p>As mentioned in the previous post the reason we need to do this is because we will be making requests to contactUrl on the client side which means we need to have this variable bundled up in our js files.</p>
<div class="blog-note">
    Warning: Do not add any secret or sensitive details/keys to the env property in nuxt.config.js as they will be publicly exposed in our js files
</div>  

<p>Make sure you also update your create-env.js if deploying to Netlify. Also update your environment variables in Netlify.</p>
<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)
fs.writeFileSync(&#39;./.env&#39;, `
BASE_URL=${process.env.BASE_URL}\n
POSTS_URL=${process.env.POSTS_URL}\n
URL=${process.env.URL}\n
PER_PAGE=${process.env.PER_PAGE}\n
SEARCH_URL=${process.env.SEARCH_URL}\n
FORMS_TOKEN=${process.env.FORMS_TOKEN}
`)</code></pre>
<h2 id="adding-the-contact-page">Adding the Contact Page</h2>
<p>Now that we know our contact form is working as expected we can go and set it up in our blog.</p>
<p>First we&#39;ll just update our PageNav.vue component to add a link to the new page:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;nav class=&quot;text-center my-4&quot;&gt;
    &lt;a href=&quot;/&quot; class=&quot;p-2 text-sm sm:text-lg inline-block text-gray-800 hover:underline&quot;&gt;Blog&lt;/a&gt;
    &lt;a href=&quot;/about&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;About&lt;/a&gt;
    &lt;a href=&quot;/search&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;Search&lt;/a&gt;
    &lt;a href=&quot;/contact&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;Contact&lt;/a&gt;
  &lt;/nav&gt;
&lt;/template&gt;</code></pre>
<p>Then create a new file in the pages directory called <code>contact.vue</code> and put the following inside.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section class=&quot;my-8&quot;&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;Contact Page&lt;/h1&gt;
      &lt;p class=&quot;mb-8&quot;&gt;
        This is a basic contact form working with Cockpit CMS!
      &lt;/p&gt;
    &lt;/div&gt;

    &lt;form @submit=&quot;checkForm&quot; method=&quot;post&quot;&gt;
      &lt;div class=&quot;mb-4&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;Name:&lt;/label&gt;
        &lt;input v-model=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot; placeholder=&quot;Your Name&quot; class=&quot;block mt-2 bg-gray-200 rounded w-full py-2 px-3&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;mb-4&quot;&gt;
        &lt;label for=&quot;mail&quot;&gt;Email:&lt;/label&gt;
        &lt;input v-model=&quot;email&quot; type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Your Email&quot; class=&quot;block mt-2 bg-gray-200 rounded w-full py-2 px-3&quot;&gt;
      &lt;/div&gt;
      &lt;div class=&quot;mb-4&quot;&gt;
        &lt;label for=&quot;msg&quot;&gt;Message:&lt;/label&gt;
        &lt;textarea v-model=&quot;message&quot; name=&quot;message&quot; placeholder=&quot;Your Message&quot; class=&quot;block mt-2 bg-gray-200 rounded w-full py-2 px-3&quot;&gt;&lt;/textarea&gt;
      &lt;/div&gt;
      &lt;div class=&quot;mb-4&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Send message&quot; :class=&quot;{ &#39;cursor-not-allowed opacity-50&#39;: loading }&quot; class=&quot;cursor-pointer bg-blue-500 hover:bg-blue-400 text-white font-bold py-2 px-4 border-b-4 border-blue-600 hover:border-blue-500 rounded&quot;&gt;
      &lt;/div&gt;
      &lt;div v-if=&quot;errors.length&quot; class=&quot;mb-4 text-red-500&quot;&gt;
        &lt;b&gt;Please correct the following error(s):&lt;/b&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;error in errors&quot; :key=&quot;error&quot;&gt;
            {{ error }}
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div v-if=&quot;success&quot; class=&quot;text-green-500&quot;&gt;
        &lt;b&gt;Your message has been sent succesfully&lt;/b&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import axios from &#39;axios&#39;

export default {
  head () {
    return {
      title: &#39;Contact&#39;,
      meta: [
        { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;This is the contact page!&#39; }
      ]
    }
  },

  data: function () {
    return {
      errors: [],
      name: null,
      email: null,
      message: null,
      loading: false,
      success: false
    }
  },

  methods: {
    checkForm: function (e) {
      this.errors = []
      this.success = false

      if (!this.name) {
        this.errors.push(&quot;Name required&quot;)
      }
      if (!this.email) {
        this.errors.push(&#39;Email required&#39;)
      } else if (!this.validEmail(this.email)) {
        this.errors.push(&#39;Valid email required&#39;)
      }
      if (!this.message) {
        this.errors.push(&quot;Message required&quot;)
      }

      if (!this.errors.length) {
        this.submitForm()
      }

      e.preventDefault()
    },

    submitForm: function () {
      this.loading = true

      axios.post(process.env.contactUrl,
      JSON.stringify({
          form: {
            name: this.name,
            email: this.email,
            message: this.message
          }
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })
      .then(({ data }) =&gt; {
        this.loading = false

        if(data.error){
          this.errors.push(data.error)
        } else if(data.name &amp;&amp; data.email &amp;&amp; data.message) {
          this.name = this.email = this.message = null
          this.success = true
        }
      }).catch(error =&gt; {
        this.loading = false

        this.errors.push(&#39;An error occured, please try again later&#39;)
      })
    },

    validEmail: function (email) {
      let re = /^(([^&lt;&gt;()\[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()\[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
      return re.test(email)
    }
  }
}
&lt;/script&gt;</code></pre>
<p>As you can see we have some basic fields for our form and on submitting the form we perform some client side validation following the example in the Vue documentation <a href="https://vuejs.org/v2/cookbook/form-validation.html">here</a>. </p>
<p>If there are no client side validation errors then we call the submitForm method and use axios to make a POST request to our <code>contactUrl</code> endpoint. Then we simply display some text with a success message or an error if there is one present.</p>
<p>If no error is present we check if an entry has been returned with name, email and message details (this is what happens when a form is succesfully submitted).</p>
<p>You can fire up your local site using <code>npm run dev</code> and test this contact form out. You should receive an email notification and be able to see the entry in Cockpit.</p>
<h2 id="adding-server-side-validation">Adding Server Side Validation</h2>
<p>At the moment we only have validation for our form fields on the client side which can be circumvented, we need to also add validation for our fields in Cockpit.</p>
<p>We can add custom validation for our form fields in Cockpit by creating a new file with the same name as our form (in our case <code>contact</code>) in the config/forms directory. You will need to create the forms directory first.</p>
<p>Then make a new file called <code>contact.php</code> and put the following inside:</p>
<pre><code class="language-php">&lt;?php

if (empty($data[&#39;name&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The name field is required&#39;], 200);
}

if (!filter_var($data[&#39;email&#39;], FILTER_VALIDATE_EMAIL)) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;A valid email is required&#39;], 200);
}

if (empty($data[&#39;message&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The message field is required&#39;], 200);
}

return true;</code></pre>
<p>The form data is available in the $data variable. This is only really simple validation for an example.</p>
<p>I initially had <code>return false;</code> inside each of the above valiation checks however it didn&#39;t give any information to the client about why the validation had failed. Instead we&#39;re stopping Cockpit and returning an error message with more details. You can return a 412 status code or something else if you like and handle these responses in axios <code>catch()</code> if you&#39;d prefer.</p>
<p>To test out if this validation is working on the server we need to send a POST request using Postman/Insomnia with <code>name</code> set to null.</p>
<p>If you don&#39;t have Postman or Insomnia just comment out the following in contact.vue to temporarily disable to client side validation then submit the form on the front end without setting a value for the name field:</p>
<pre><code class="language-javascript">checkForm: function (e) {
  this.errors = []
  this.success = false

  /* if (!this.name) {
    this.errors.push(&quot;Name required&quot;)
  }
  if (!this.email) {
    this.errors.push(&#39;Email required&#39;)
  } else if (!this.validEmail(this.email)) {
    this.errors.push(&#39;Valid email required&#39;)
  }
  if (!this.message) {
    this.errors.push(&quot;Message required&quot;)
  } */

  if (!this.errors.length) {
    this.submitForm()
  }

  e.preventDefault()
},</code></pre>
<p>Now if you&#39;ve added the contact.php file correctly you should notice that the response is returned with an error message if validation fails on the server. You shouldn&#39;t receive a notification email and there should not be a new entry visible in Cockpit.</p>
<h2 id="spam-prevention">Spam Prevention</h2>
<p>If you have any kind of contact form on your site it is very likely you will have received spam from automated bots.</p>
<p>To help prevent this you can add a Google reCAPTCHA to your site/form.</p>
<p>If you&#39;d rather not use reCAPTCHA another simple method is available known as a Honeypot trap.</p>
<p>The idea is that you add a hidden text field or checkbox to your form that the user cannot see. A bot that is filling out the form will also accidently fill out this hidden field, in our server side validation we can check if this hidden field has been filled our (or checkbox ticked) and if it has we simply return false from our <code>contact.php</code> script.</p>
<p>Let&#39;s add a really simple honeypot field to our form. Above the input button add this new field:</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; name=&quot;website&quot; v-model=&quot;website&quot; class=&quot;hidden opacity-0 z-0&quot; tabindex=&quot;-1&quot; autocomplete=&quot;off&quot;&gt;</code></pre>
<p>We&#39;ve given it a real looking name and set it to display: none, with 0 opacity and a z-index of 0. We&#39;ve also set tabindex as -1 to prevent the user selecting the field by clicking tab and set autocomplete as off to prevent a user&#39;s browser accidently autocompleting and filling in the field.</p>
<p>Make sure to add website to the page&#39;s data:</p>
<pre><code class="language-javascript">data: function () {
  return {
    errors: [],
    name: null,
    email: null,
    message: null,
    website: null,
    loading: false,
    success: null
  }
},</code></pre>
<p>Also add it when posting the request to Cockpit:</p>
<pre><code class="language-javascript">submitForm: function () {
  this.loading = true

  axios.post(process.env.contactUrl,
  JSON.stringify({
      form: {
        name: this.name,
        email: this.email,
        message: this.message,
        website: this.website
      }
    }),
  {
    headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
  })
  .then(({ data }) =&gt; {
    this.loading = false

    if(data.error){
      this.errors.push(data.error)
    } else if(data.name &amp;&amp; data.email &amp;&amp; data.message) {
      this.name = this.email = this.message = null
      this.success = true
    }
  }).catch(error =&gt; {
    this.loading = false

    this.errors.push(&#39;An error occured, please try again later&#39;)
  })
},</code></pre>
<p>Now all that&#39;s left to do is to update <code>contact.php</code> in the config/forms directory.</p>
<pre><code class="language-php">&lt;?php

if (isset($data[&#39;website&#39;])) {
    return false;
}

if (empty($data[&#39;name&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The name field is required&#39;], 200);
}

if (!filter_var($data[&#39;email&#39;], FILTER_VALIDATE_EMAIL)) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;A valid email is required&#39;], 200);
}

if (empty($data[&#39;message&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The message field is required&#39;], 200);
}

return true;</code></pre>
<p>We just add a check for the new website honeypot field, if it is not set to null then the submission will fail vailidation and be rejected. We&#39;re just returning false here instead of a validation error message but you can add one if you like.</p>
<p>The only potential downside to this method of spam prevention is if a real user someone manages to accidently fill in the website field and their legitimate submission is rejected.</p>
<p>To make sure we don&#39;t lose a genuine submission we should add logging or save all entries that fail the honeypot field test. That way we can check every so often which submissions have been rejected and see if any are authentic.</p>
<p>One way we could do this is by creating a new form called <code>bots</code> without setting an email and without setting save form data as true.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/05/5ca72b7ee69b3cockpit-bots-form.png" alt="Cockpit Bots Form"></p>
</div>

<p>Then we can just update our custom validation for contact at <code>config/forms/contact.php</code> and add the following:</p>
<pre><code class="language-php">&lt;?php

if (isset($data[&#39;website&#39;])) {

    // save the submission in case it is actually a genuine one
    cockpit(&#39;forms&#39;)-&gt;save(&#39;bots&#39;, [&#39;data&#39; =&gt; $data]);

    return false;
}

if (empty($data[&#39;name&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The name field is required&#39;], 200);
}

if (!filter_var($data[&#39;email&#39;], FILTER_VALIDATE_EMAIL)) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;A valid email is required&#39;], 200);
}

if (empty($data[&#39;message&#39;])) {
    $this-&gt;app-&gt;stop([&#39;error&#39; =&gt; &#39;The message field is required&#39;], 200);
}

return true;</code></pre>
<p>Now if you send a POST request to your contact form and make sure to set website as some value then you should see the submission is saved in your bots form entries at <code>cms.yourdomain.com/forms/entries/bots</code>.</p>
<p>This obviously doesn&#39;t prevent against a bot sending direct POST requests to our form&#39;s endpoint and omitting the website field but it should be fine for most situations.</p>
<p>If you want to make sure that ONLY the fields you want can be posted to your form then you can add something like this to your validation:</p>
<pre><code class="language-php">foreach($data as $field =&gt; $value){
    if(!in_array($field, [&#39;website&#39;, &#39;name&#39;, &#39;email&#39;, &#39;message&#39;])){
        return false;
    }
}</code></pre>
<p>Now if any additional field is added or sent the validation will fail.</p>
<p>You can always change the name of the honeypot field or update it to a checkbox if you notice spam coming through.</p>
<p>You should now have a contact form with client + server side validation and basic spam bot protection that looks like this:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/04/05/5ca72f15d8137contact-form.png" alt="Contact Form"></p>
</div>

<p>You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here</a> and see a live demo of the site on Netlify here - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 5: Searching Posts]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-5-searching-posts</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-5-searching-posts">
        </link>
        <updated>2019-02-28T08:52:04Z</updated>
        <summary type="html"><![CDATA[In this post of our Nuxt Cockpit series we'll be looking at how to add basic live search functionality for our blog posts so that readers can quickly find what they're looking for. To achieve this we'll be using an awesome service called Algolia.]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Parts 1, 2, 3 and 4 of this guide you can find them here:</p>
<ul>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment/">Part 3: Deployment</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-4-post-pagination">Part 4: Post Pagination</a></li>
</ul>
<h2 id="adding-live-search-on-a-static-blog">Adding Live Search on a Static Blog</h2>
<p>Typically when searching for something you would submit a form that would then be sent to a backend which would then query a database and return the results.</p>
<p>If you want to implement live searching you need to send requests in real time as the user is typing so results can be displayed almost immediately.</p>
<p>Since our site is just a static blog made up of plain old HTML, CSS and Javascript we&#39;ll need to send requests elsewhere to get our search results.</p>
<p>Luckily for us Cockpit has a full-text search addon called <a href="https://github.com/agentejo/Detektivo">Detektivo</a>. To install this addon you simply need to add the files to your Cockpit CMS directory under addons/Detektivo.</p>
<p>You can do this by running the following commands from the command line.</p>
<pre><code class="language-bash">cd /path/to/your/cms-yourblog/
cd addons
git clone https://github.com/agentejo/Detektivo.git</code></pre>
<p>Detektivo supports a few different engines; Algolia, ElasticSearch and TNTSearch. We will be using <a href="https://www.algolia.com/">Algolia</a> here so visit the website and create an account (It has a great free tier).</p>
<p>Once you&#39;ve created your Algolia account you can get your Application ID and Admin API Key. We need the Admin Key and not the Search-Only Key as we will be using it to add/update index records to be searched. </p>
<p>Now we need to update our config.yaml file in Cockpit. So go to settings and then click settings again and you should see a text editor.</p>
<p>Add the following inside:</p>
<pre><code class="language-yaml"># Search settings
detektivo:
    engine: algolia
    app_id: &lt;YOUR-APP-ID&gt;
    api_key: &lt;YOUR-API-KEY&gt;
    collections:
        posts: [title, title_slug, excerpt]</code></pre>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/02/28/5c77fc2393441cockpit-search-config.png" alt="Cockpit Search Config"></p>
</div>

<p>Under collections you can see &#39;posts&#39;, this is in reference to our posts collection. The array  containing title, title_slug and excerpt are the fields in this collection that we wish to be included in our index in Algolia.</p>
<div class="blog-note">
    Note: You can add the post content field here as well as the excerpt however be aware that this will potentially make the records too big and you may get errors from Algolia when using the API
</div>

<p>Read more about record size limits here - <a href="https://www.algolia.com/doc/faq/basics/is-there-a-size-limit-for-my-index-records/">https://www.algolia.com/doc/faq/basics/is-there-a-size-limit-for-my-index-records/</a></p>
<p>It is probably best to do just the title, title_slug and excerpt fields to be on the safe side.</p>
<h2 id="adding-our-posts-index-to-algolia">Adding Our Posts Index to Algolia</h2>
<p>Whilst logged in to Algolia create a new index and call it <code>posts</code>. There won&#39;t be any records here yet as we have not added them.</p>
<p>In Algolia you can add records in three different ways; manually, by file upload or via the API.</p>
<p>We&#39;ll be using the API which is why we needed to add our Admin Key in our Cockpit configuration.</p>
<h2 id="adding-our-posts-to-algolia">Adding Our Posts to Algolia</h2>
<p>If you head back over to Cockpit and click on the menu you should see a new item under &#39;DETEKTIVO&#39; called Manage Index, click on it.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/02/28/5c77fca8e0e8acockpit-manage-index.png" alt="Cockpit Manage Index"></p>
</div>

<p>You&#39;ll see your posts collection is listed because you added it in config.yaml. The number 4 refers to the number of fields that will be indexed. (This will be 3 if you just have title, title_slug and excerpt).</p>
<p>If you now click the refresh icon to Re-Index the posts they will become visible in Algolia.</p>
<p>You can edit the configuration for this index by going to - <code>www.algolia.com/apps/&lt;YOUR-APP-ID&gt;/explorer/configuration/posts/searchable-attributes</code></p>
<p>Here you can add things like searchable attributes, rankings and set up result highlighting.</p>
<p>You may wish to update the Search behavior &gt; Retrieved attributes to be just the title and title_slug so that the response will be smaller and easier to read.</p>
<p>Now that we have some records in Algolia that can be searched we can make a GET request using Postman or Insomnia or even by just visiting the URL in the browser.</p>
<p>The endpoint we&#39;ll be using with Detektivo will be <code>cms.yourdomain.com/api/detektivo/collection/posts?token=&lt;COCKPIT-SEARCH-API-KEY&gt;&amp;q={searchterm}</code></p>
<p>Where <code>&lt;COCKPIT-SEARCH-API-KEY&gt;</code> is a key we&#39;ve yet to create.</p>
<p>The great thing about the Detektivo addon is that each time you add/update/delete a post it automatically updates our posts index at Algolia for us.</p>
<h2 id="adding-a-search-only-api-key-in-cockpit">Adding a Search-Only API Key in Cockpit</h2>
<p>We need to create a new API key in Cockpit however we need to make sure it only has permissions to perform searches on our posts collection and nothing else. That is because the key will be public and exposed in each request made.</p>
<p>We <code>MUST NOT</code> use our MASTER API-KEY or any other Key we&#39;ve previously created in Cockpit.</p>
<p>So head over to Settings then API Access in Cockpit and click the little plus icon to generate a new API Key.</p>
<p>Make sure to add <code>/api/detektivo/collection/posts</code> in the rules section like so:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/02/28/5c77f61a3157dcockpit-search-only-api-key.png" alt="Cockpit Search-Only API Key"></p>
</div>

<p>This rule means only requests made to that endpoint with the key will be authorised.</p>
<p>Now if you make a get request to the endpoint mentioned above with a search term you know exists in the title of one of your posts you should see some results returned.</p>
<h2 id="updating-our-blogs-environment-variables">Updating Our Blogs Environment Variables</h2>
<p>Open up your .env file for Nuxt and add a new variable called SEARCH_URL.</p>
<pre><code>SEARCH_URL=https://cms.yourdomain.com/api/detektivo/collection/posts?token=*COCKPIT-SEARCH-API-KEY*&amp;q=</code></pre><p>Now we also need to update our nuxt.config.js and add an env property. Add the following anywhere inside module.exports = { ... }</p>
<pre><code class="language-javascript">env: {
  searchUrl: process.env.SEARCH_URL
},</code></pre>
<p>The reason we need to do this is because we will be making requests to our searchUrl on the client side which means we need to have this variable bundled up in our js files.</p>
<div class="blog-note">
    Warning: Do not add any secret or sensitive details/keys to the env property as they will be publicly exposed in our js files
</div>  

<p>Now we will be able to access the searchUrl variable even after our site has been generated. Don&#39;t worry, the token we are using is our Search-Only Key so nobody will be able to delete or edit our posts etc.</p>
<p>Make sure you also update your create-env.js if deploying to Netlify.</p>
<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)
fs.writeFileSync(&#39;./.env&#39;, `
BASE_URL=${process.env.BASE_URL}\n
POSTS_URL=${process.env.POSTS_URL}\n
URL=${process.env.URL}\n
PER_PAGE=${process.env.PER_PAGE}\n
SEARCH_URL=${process.env.SEARCH_URL}
`)</code></pre>
<h2 id="adding-a-new-search-page">Adding a New Search Page</h2>
<p>First we&#39;ll just update our PageNav.vue component to add a link to the new page:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;nav class=&quot;text-center my-4&quot;&gt;
    &lt;a href=&quot;/&quot; class=&quot;p-2 text-sm sm:text-lg inline-block text-gray-800 hover:underline&quot;&gt;Blog&lt;/a&gt;
    &lt;a href=&quot;/about&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;About&lt;/a&gt;
    &lt;a href=&quot;/search&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;Search&lt;/a&gt;
  &lt;/nav&gt;
&lt;/template&gt;</code></pre>
<p>In the pages directory of your blog add a new file called <code>search.vue</code> and put the following inside it:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section class=&quot;my-8&quot;&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;Search Page&lt;/h1&gt;
      &lt;p&gt;
        This is a live search example using Algolia and Cockpit!
      &lt;/p&gt;

      &lt;div class=&quot;my-8&quot;&gt;

        &lt;input type=&quot;text&quot; name=&quot;searchTerm&quot; v-model=&quot;searchTerm&quot; placeholder=&quot;Search Posts...&quot; class=&quot;text-center block mt-2 bg-gray-200 rounded w-full py-2 px-3&quot;&gt;

        &lt;div v-if=&quot;results.length !==0&quot; class=&quot;search-results&quot;&gt;
          &lt;a v-for=&#39;result in results&#39; :key=&quot;result.title_slug&quot; :href=&quot;&#39;/&#39;+result.title_slug&quot; class=&quot;block text-gray-800 p-3 text-left&quot;&gt;
            {{ result.title }}
          &lt;/a&gt;
        &lt;/div&gt;

        &lt;div v-else-if=&quot;searchTerm.length &gt;= 3&quot;&gt;
          &lt;span class=&quot;block text-gray-800 p-3 text-left&quot;&gt;
            No results found
          &lt;/span&gt;
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import axios from &#39;axios&#39;;

export default {
  data: function () {
    return {
      searchTerm: &#39;&#39;,
      results:[]
    }
  },

  watch: {
    searchTerm: &#39;search&#39;
  },

  methods: {
    search() {
      if(this.searchTerm.length &lt; 3){
        return this.results = []
      }

      axios.get(process.env.searchUrl+this.searchTerm)
      .then(response =&gt; {
        this.results = response.data.hits
      })
    }
  }
}
&lt;/script&gt;</code></pre>
<p>So what we&#39;re doing here is simply telling Nuxt to watch the searchTerm variable and to call the search method when it changes. If it has a length longer than 2 we will make a call to Cockpit to fetch the search results.</p>
<p>These results are then displayed and they use the title_slug as the url for the link.</p>
<h2 id="adding-highlighting-for-results">Adding Highlighting for Results</h2>
<p>To improve these results we could add highlighting by changing <code>{{ result.title }}</code> to:</p>
<pre><code class="language-html">&lt;span v-html=&quot;result._highlightResult.title.value&quot;&gt;&lt;/span&gt;</code></pre>
<p>To make this work you first need to go to Algolia and add the title to <code>Attributes to highlight</code> in Pagination and Display &gt; Highlighting.</p>
<p>This will return the highlighted title word(s) wrapped in <code>&lt;em&gt;&lt;/em&gt;</code> tags by default. That is why we need to use v-html otherwise the em tags would simply be rendered as a string.</p>
<p>You could then add a simple css rule to give the em tag a nice background colour for highlighting.</p>
<p>You can add something like this to main.css</p>
<pre><code class="language-css">/* purgecss ignore */
.search-results em {
  @apply not-italic bg-blue-200;
}</code></pre>
<p>I&#39;ve added a purgecss ignore comment here to make sure this css isn&#39;t removed when we build the site because <code>.search-results em</code> will not actually exist at build time as it is only present if we search on the client side so the css would be removed otherwise.</p>
<p>We could also add highlighting for the post excerpt. However the excerpt may be too long so we don&#39;t want to display the whole thing in the results. </p>
<h2 id="snippeting-the-post-excerpt">Snippeting The Post Excerpt</h2>
<p>Algolia offers a feature called snippeting that allows us to only display a snippet of text around the matched word(s).</p>
<p>If you visit Attributes to snippet in Algolia and add <code>excerpt</code> then you can update the html to the following:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section class=&quot;my-8&quot;&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;Search Page&lt;/h1&gt;
      &lt;p&gt;
        This is a live search example using Algolia and Cockpit!
      &lt;/p&gt;

      &lt;div class=&quot;my-8&quot;&gt;

        &lt;input type=&quot;text&quot; name=&quot;searchTerm&quot; v-model=&quot;searchTerm&quot; placeholder=&quot;Search Posts...&quot; class=&quot;text-center block mb-4 shadow text-gray-600 rounded w-full py-2 px-3&quot;&gt;

        &lt;div v-if=&quot;results.length !==0&quot; class=&quot;search-results&quot;&gt;
          &lt;a v-for=&#39;result in results&#39; :key=&quot;result.title_slug&quot; :href=&quot;&#39;/&#39;+result.title_slug&quot; class=&quot;block text-gray-800 p-3 text-left&quot;&gt;
            &lt;span v-html=&quot;result._highlightResult.title.value&quot; class=&quot;block font-bold mb-1&quot;&gt;&lt;/span&gt;
            &lt;span v-html=&quot;result._snippetResult.excerpt.value&quot;&gt;&lt;/span&gt;
          &lt;/a&gt;
        &lt;/div&gt;

        &lt;div v-else-if=&quot;searchTerm.length &gt;= 3&quot;&gt;
          &lt;span class=&quot;block text-gray-800 p-3 text-left&quot;&gt;
            No results found
          &lt;/span&gt;
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<p>You should now see something like this:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/03/01/5c79010acc040static-blog-search.png" alt="Static Blog Search"></p>
</div>

<p>With title and excerpt highlighting and also snippeting for the post excerpt.</p>
<p>You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here</a> and see a live demo of the site on Netlify here - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 4: Post Pagination]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-4-post-pagination</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-4-post-pagination">
        </link>
        <updated>2018-11-12T12:15:17Z</updated>
        <summary type="html"><![CDATA[This is just an additional post for our Nuxt Cockpit series looking at handling pagination for our blog posts when we statically generate our site.]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Parts 1, 2, and 3 of this guide you can find them here:</p>
<ul>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></li>
<li><a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment/">Part 3: Deployment</a></li>
</ul>
<h2 id="adding-pagination-to-our-blog">Adding Pagination to our Blog</h2>
<p>Open up your .env file and add the following variable to it </p>
<pre><code class="language-env">PER_PAGE=2</code></pre>
<p>We&#39;re setting it low on purpose so we can easily see the pagination in action. </p>
<p>Then at the top of nuxt.config.js add this line:</p>
<pre><code class="language-javascript">const perPage = Number(process.env.PER_PAGE)</code></pre>
<p>Now that we have our perPage variable we can update our generate: property by adding the following just below <code>let posts = ...</code></p>
<pre><code class="language-javascript">if(perPage &lt; data.total) {
  let pages = collection
  .take(perPage-data.total)
  .chunk(perPage)
  .map((items, key) =&gt; {
    let currentPage = key + 2

    return {
      route: `blog/${currentPage}`,
      payload: {
        posts: items.all(),
        hasNext: data.total &gt; currentPage*perPage
      }
    }
  }).all()

  return posts.concat(tags,pages)
}</code></pre>
<p>So breaking this down, first we check if the value we have set to display per page is less than the total number of blog posts.</p>
<p>If it is less and for example we have set 10 posts per page but there are 25 posts in total. Then with the <code>take</code> method we take (10 - 25) which equals -15 posts. The negative integer means we want to take 15 posts from the end of the posts collection. More information on this is in the <a href="https://github.com/ecrmnn/collect.js/#take">collectjs docs</a>.</p>
<p>The reason we only want to take from the end of the collection is because we do not want to include the first page of posts as this is currently already set as our blog&#39;s home page. (We already have 10 posts on the home page that we don&#39;t need to include for pagination)</p>
<p>Next we chunk the 15 posts we&#39;ve got by the <code>perPage</code> variable, so we would have 10 and 5 in two chunks.</p>
<p>Then we simply map these items into their respective pages, where <code>currentPage</code> is the key that we add 2 onto since the first chunk will have a key of 0 however we want this to effectively be our page 2 (as we&#39;re going to count our home page as page 1).</p>
<p>We pass the post items in each chunk as the payload to use and we also pass a <code>hasNext</code> variable that lets us know if there is another page or not. In our example here <code>data.total</code> is 25 as there are 25 posts in total. When we&#39;re in the second chunk that contains 5 posts the  chunk key will be 1 so we have (1 + 2)*10 which is 30. So <code>hasNext</code> will evaluate to false.</p>
<h2 id="adding-the-blog-page">Adding the Blog Page</h2>
<p>We&#39;re going to set our blog up so that pages are found at <code>yourdomain.com/blog/2</code> etc. You can instead do <code>yourdomain.com/2</code>, <code>yourdomain.com/blog/page-2</code> or whatever you prefer.</p>
<p>In the pages directory create a new folder called <code>blog</code> and add a file named <code>_page.vue</code> to it. Put the following code inside:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;div class=my-8&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;Blog Page {{ page }}&lt;/h1&gt;
      &lt;ul class=&quot;flex flex-col w-full p-0&quot;&gt;
        &lt;li class=&quot;mb-6 w-full&quot; v-for=&quot;(post, key) in posts&quot; :key=&quot;key&quot;&gt;
          &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
            {{ post._created | toDate }}
            &lt;a v-for=&quot;(tag, key) in post.tags&quot; :key=&quot;key&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
          &lt;/div&gt;

          &lt;a :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            &lt;h2 class=&quot;my-2 text-gray-800 text-lg lg:text-xl font-bold&quot;&gt;
              {{ post.title }}
            &lt;/h2&gt;
          &lt;/a&gt;

          &lt;div class=&quot;page-content hidden md:block text-base mb-2&quot; v-html=&quot;post.excerpt&quot;&gt;
          &lt;/div&gt;
          &lt;a class=&quot;text-sm text-blue-400&quot; :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            Read more
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div class=&quot;flex justify-center mt-8&quot;&gt;
        &lt;a :href=&quot;page === &#39;2&#39; ? &#39;/&#39; : `/blog/${Number(page)-1}`&quot; class=&quot;text-sm pr-2&quot;&gt;
          Previous Page
        &lt;/a&gt;
        &lt;a v-if=&quot;hasNext&quot; :href=&quot;`/blog/${Number(page)+1}`&quot; class=&quot;text-sm pl-2&quot;&gt;
          Next Page
        &lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  async asyncData ({ app, params, error, payload }) {
    if (payload) {
      return { posts: payload.posts, page: params.page, hasNext: payload.hasNext }
    } else {
      let { data } = await app.$axios.post(process.env.POSTS_URL,
      JSON.stringify({
          filter: { published: true },
          limit: process.env.PER_PAGE,
          skip: (params.page-1)*process.env.PER_PAGE,
          sort: {_created:-1},
          populate: 1
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })

      if (!data.entries[0]) {
        return error({ message: &#39;404 Page not found&#39;, statusCode: 404 })
      }

      return { posts: data.entries, page: params.page, hasNext: Number((params.page-1)*process.env.PER_PAGE) + Number(process.env.PER_PAGE) &lt; data.total }
    }
  },
  head () {
    return {
      title: `Nuxt Cockpit Static Blog - Page ${this.page}`
    }
  }
}
&lt;/script&gt;</code></pre>
<p>Notice the limit and skip options we added when fetching the posts for the dev server.</p>
<p>When our blog has been generated it will be using the payload we passed through in nuxt.config.js.</p>
<p>We do a quick check to see if the current page is 2 when rendering the previous link as we don&#39;t want to link to <code>yourdomain.com/blog/1</code> as that page doesn&#39;t exist, we want to simply go back to the home page to display our first page of posts.</p>
<p>Head over to index.vue in pages and update that too so we have a next page if there is one available.</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;div class=my-8&gt;
      &lt;ul class=&quot;flex flex-col w-full p-0&quot;&gt;
        &lt;li class=&quot;mb-6 w-full&quot; v-for=&quot;(post, key) in posts&quot; :key=&quot;key&quot;&gt;
          &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
            {{ post._created | toDate }}
            &lt;a v-for=&quot;tag in post.tags&quot; :key=&quot;tag&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
          &lt;/div&gt;

          &lt;a :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            &lt;h2 class=&quot;my-2 text-gray-800 text-lg lg:text-xl font-bold&quot;&gt;
              {{ post.title }}
            &lt;/h2&gt;
          &lt;/a&gt;

          &lt;div class=&quot;page-content hidden md:block text-base mb-2&quot; v-html=&quot;post.excerpt&quot;&gt;
          &lt;/div&gt;
          &lt;a class=&quot;text-sm text-blue-400&quot; :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            Read more
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div v-if=&quot;hasNext&quot; class=&quot;flex justify-center mt-8&quot;&gt;
        &lt;a href=&quot;/blog/2&quot; class=&quot;text-sm&quot;&gt;
          Next Page
        &lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  async asyncData ({ app, error }) {
    const { data } = await app.$axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        limit: process.env.PER_PAGE,
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })

    if (!data.entries[0]) {
      return error({ message: &#39;404 Page not found&#39;, statusCode: 404 })
    }

    return { posts: data.entries, hasNext: process.env.PER_PAGE &lt; data.total }
  }
}
&lt;/script&gt;</code></pre>
<p>Notice we&#39;ve added the limit option when fetching our posts which is set to our <code>PER_PAGE</code> environment variable.</p>
<p>If you visit the site now you should see the home page with two posts and a next link. If you click next you&#39;ll be taken to <code>/blog/2</code> and depending on how many posts you&#39;ve got in Cockpit you&#39;ll see a previous and next link on this page.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/11/12/5be984f90c881nuxt-pagination.png" alt="Nuxt Pagination"></p>
</div>

<h2 id="update-our-netlify-script">Update our Netlify Script</h2>
<p>We also need to remember to update our <code>create-env.js</code> file for Netlify.</p>
<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)
fs.writeFileSync(&#39;./.env&#39;, `
API_TOKEN=${process.env.API_TOKEN}\n
BASE_URL=${process.env.BASE_URL}\n
POSTS_URL=${process.env.POSTS_URL}\n
URL=${process.env.URL}\n
PER_PAGE=${process.env.PER_PAGE}
`)</code></pre>
<p>Make sure to update your environment variables when you are logged into Netlify like we did in Part 3 so that <code>PER_PAGE</code> is included.</p>
<h2 id="updating-our-sitemap">Updating our Sitemap</h2>
<p>We also need to update our sitemap otherwise it won&#39;t be aware of our new blog pages so open up nuxt.config.js and update it to the following:</p>
<pre><code class="language-javascript">sitemap: {
  path: &#39;/sitemap.xml&#39;,
  hostname: process.env.URL,
  cacheTime: 1000 * 60 * 15,
  generate: true, // Enable me when using nuxt generate
  async routes () {
    let { data } = await axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })

    const collection = collect(data.entries)

    let tags = collection.map(post =&gt; post.tags)
    .flatten()
    .unique()
    .map(tag =&gt; `category/${tag}`)
    .all()

    let posts = collection.map(post =&gt; post.title_slug).all()

    if(perPage &lt; data.total) {
      let pages = collection
      .take(perPage-data.total)
      .chunk(perPage)
      .map((items, key) =&gt; `blog/${key+2}`)
      .all()

      return posts.concat(tags,pages)
    }

    return posts.concat(tags)
  }
},</code></pre>
<p>Now at the moment we only have pagination set up for our blog posts from all categories. If we wanted to go further we could also set up pagination per category to something like <code>yourdomain.com/category/nuxt/2</code> etc.</p>
<p>Update your .env <code>PER_PAGE</code> variable to something sensible like 10 and you should be good to go!</p>
<p>You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here</a> and see a live demo of the site on Netlify here - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Simple Referral System in Laravel]]></title>
        <id>https://willbrowning.me/building-a-simple-referral-system-in-laravel</id>
        <link href="https://willbrowning.me/building-a-simple-referral-system-in-laravel">
        </link>
        <updated>2018-10-26T10:23:49Z</updated>
        <summary type="html"><![CDATA[In this post we'll carry on from the previous one regarding sharing cookies with a subdomain and use what we learned to build a simple referral system to track who has referred users when they register on the site.]]></summary>
        <content type="html"><![CDATA[<p>This post is a continuation of <a href="https://willbrowning.me/sharing-cookies-with-subdomains-in-laravel/">Sharing Cookies with Subdomains in Laravel</a> so if you have not read that please go and check it out.</p>
<h2 id="adding-authentication-to-our-subdomain">Adding Authentication to our Subdomain</h2>
<p>In the example we&#39;re making here I&#39;ll be adding authentication to <code>app.example.test</code> and we&#39;ll be treating <code>example.test</code> as the marketing frontend for our application.</p>
<p>So let&#39;s edit our Homestead.yaml file and add a database we can use for our authentication.</p>
<pre><code class="language-yaml">databases:
    - example</code></pre>
<p>Then run <code>homestead up --provision</code> or <code>homestead reload --proivision</code> if homestead is already running.</p>
<p>Now we need to ssh into homestead so run <code>homestead ssh</code> and navigate to the directory where <code>app.example.test</code> is located. Then run the following:</p>
<pre><code class="language-bash">php artisan make:auth</code></pre>
<p>You should now be able to see the login and register pages.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/10/26/5bd2eaf94690bregister-example.png" alt="Register Example"> </p>
</div>

<h2 id="creating-middleware-to-set-our-cookie">Creating Middleware to Set our Cookie</h2>
<p>In our <code>example.test</code> code create some new Middleware called <code>CheckReferral</code>.</p>
<pre><code class="language-bash">php artisan make:middleware CheckReferral</code></pre>
<p>Open up the newly created file and edit the handle function.</p>
<pre><code class="language-php">public function handle($request, Closure $next)
{
    if( !$request-&gt;hasCookie(&#39;referral&#39;) &amp;&amp; $request-&gt;query(&#39;ref&#39;) ) {
        return redirect($request-&gt;url())-&gt;withCookie(cookie()-&gt;forever(&#39;referral&#39;, $request-&gt;query(&#39;ref&#39;)));
    }

    return $next($request);
}</code></pre>
<p>What we are doing here is checking whether a cookie named <code>referral</code> is currently set. If it is not and the request contains a query parameter <code>ref</code> then Laravel will set a cookie named referral with the value of whatever ref is equal to that has the maximum expiry time.</p>
<p>For example the url <code>example.test/?ref=laravel</code> would set a cookie (if none already exists) with value <code>laravel</code>.</p>
<p>If we want this middleware to run during every web route HTTP request to our application then we can add it to our middleware by editing <code>app/Http/Kernel.php</code> and adding it to the &#39;web&#39; section of the $middlewareGroups property like so:</p>
<pre><code class="language-php">protected $middlewareGroups = [
    &#39;web&#39; =&gt; [
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        // \Illuminate\Session\Middleware\AuthenticateSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
        \Illuminate\Routing\Middleware\SubstituteBindings::class,
        \App\Http\Middleware\CheckReferral::class,
    ],

    &#39;api&#39; =&gt; [
        &#39;throttle:60,1&#39;,
        &#39;bindings&#39;,
    ],
];</code></pre>
<p>If you only wanted to check and set the cookie on the homepage you could simply add it to the $routeMiddleware property instead and then call it for the <code>&#39;/&#39;</code> route in web.php.</p>
<h2 id="checking-our-cookie-is-being-set">Checking our Cookie is Being Set</h2>
<p>If you remember from the previous post we had a route <code>/cookie</code> to check if the cookie had been set. Let&#39;s edit web.php and update this:</p>
<pre><code class="language-php">Route::get(&#39;/&#39;, function () {
    //Cookie::queue(Cookie::make(&#39;test&#39;, &#39;123&#39;, 60));

    return view(&#39;welcome&#39;);
});

Route::get(&#39;/cookie&#39;, function () {
    return Cookie::get(&#39;referral&#39;);
});</code></pre>
<p>Make sure to comment out or delete the Cookie::queue we added in the previous post as we don&#39;t need this anymore.</p>
<p>Now if we visit <code>example.test/?ref=laravel</code> you&#39;ll notice we&#39;re redirected to <code>example.test</code>.</p>
<p>If we go to <code>example.test/cookie</code> then you should see the value laravel returned.</p>
<p>Our cookie is currently being encrypted by Laravel but since it does not contain sensitive data lets disable it by editing <code>app/Http/Middleware/EncryptCookies.php</code>.</p>
<pre><code class="language-php">protected $except = [
     &#39;referral&#39;
 ];</code></pre>
<p>Make sure to update <code>EncryptCookies.php</code> for app.example.test too.</p>
<h2 id="registering-a-user-and-generating-a-referral-id">Registering a User and Generating a Referral ID</h2>
<p>Head over to your code for <code>app.example.test</code> and then register a new user in your browser.</p>
<p>Login with your newly created user. We&#39;ll be using a packaged called <a href="https://github.com/vinkla/laravel-hashids">hashids</a> that has been ported to Laravel to create a short unique string based on our users&#39; ID in the database.</p>
<p>So install the package by running the following:</p>
<pre><code class="language-bash">composer require vinkla/hashids</code></pre>
<p>It should be discovered automatically. Next add the Facade to our aliases list at the bottom of config/app.php</p>
<pre><code class="language-php">&#39;Hashids&#39; =&gt; Vinkla\Hashids\Facades\Hashids::class,</code></pre>
<p>Now we can publish the vendor files by running:</p>
<pre><code class="language-php">php artisan vendor:publish --provider=&quot;Vinkla\Hashids\HashidsServiceProvider&quot;</code></pre>
<p>Open up <code>config/hashids.php</code> and update the &#39;main&#39; connection. You can use laravel to generate a random string for the salt, just temporarily add <code>dd(str_random(40));</code> to any route in web.php.</p>
<pre><code class="language-php">&#39;main&#39; =&gt; [
    &#39;salt&#39; =&gt; &#39;yGPMa8oZc7PEJXxEnOIAhZscjujizzCPt028vCSG&#39;,
    &#39;length&#39; =&gt; 6,
],</code></pre>
<p>Now we will be able to generate a unique 6 character long referral ID for each user based on their ID in the database.</p>
<p>Create a new route in web.php called <code>referral-link</code>.</p>
<pre><code class="language-php">Route::get(&#39;/referral-link&#39;, &#39;HomeController@referral&#39;);</code></pre>
<p>We are using the HomeController generated by Laravel&#39;s auth scaffolding as it already has the auth middleware.</p>
<p>Edit HomeController.php:</p>
<pre><code class="language-php">public function referral()
{
    return &#39;http://example.test/?ref=&#39; . \Hashids::encode(auth()-&gt;user()-&gt;id);
}</code></pre>
<p>You should see something like this <code>http://example.test/?ref=V53YMO</code> returned.</p>
<h2 id="checking-for-the-cookie-when-registering-new-users">Checking for the Cookie When Registering New Users</h2>
<p>First let&#39;s create a new migration to add a new column to our database.</p>
<pre><code class="language-bash">php artisan make:migration add_referred_by_column_to_users_table --table=users</code></pre>
<p>Edit the new migration file in <code>database/migrations</code> </p>
<pre><code class="language-php">public function up()
{
    Schema::table(&#39;users&#39;, function (Blueprint $table) {
        $table-&gt;unsignedInteger(&#39;referred_by&#39;)-&gt;nullable()-&gt;after(&#39;email&#39;);
    });
}</code></pre>
<p>Then whilst inside Homestead and in the correct directory run <code>php artisan migrate</code>.</p>
<p>There will now be a referred_by column right after the email column in the users table.</p>
<p>Now we just need to edit <code>app/Http/Controllers/Auth/RegisterController.php</code> so we can save the referred by data.</p>
<pre><code class="language-php">use Illuminate\Support\Facades\Cookie;</code></pre>
<p>Make sure to add that to the top of the file first, then update the create function:</p>
<pre><code class="language-php">protected function create(array $data)
{
    $cookie = Cookie::get(&#39;referral&#39;);

    $referred_by = $cookie ? \Hashids::decode($cookie)[0] : null;

    return User::create([
        &#39;name&#39; =&gt; $data[&#39;name&#39;],
        &#39;email&#39; =&gt; $data[&#39;email&#39;],
        &#39;password&#39; =&gt; Hash::make($data[&#39;password&#39;]),
        &#39;referred_by&#39; =&gt; $referred_by
    ]);
}</code></pre>
<p>We check if the cookie named <code>referral</code> is set (if it is not then null is returned) then we use our Hashids package to decode the value in the cookie and give us the ID of the user who referred this new registration.</p>
<p>Hashids::decode() returns an array which is why we have to add [0].</p>
<p>Before we continue make sure to update <code>app/User.php</code> to add &#39;referred_by&#39; to the $fillable property.</p>
<pre><code class="language-php">protected $fillable = [
    &#39;name&#39;, &#39;email&#39;, &#39;password&#39;, &#39;referred_by&#39;
];</code></pre>
<h2 id="testing-it-out-with-a-new-user-registration">Testing it out With a New User Registration</h2>
<p>Before you log out of the current user visit <code>app.example.test/referral-link</code> and copy your referral link.</p>
<p>Then log out and make sure to clear all your cookies for both <code>example.test</code> and <code>app.example.test</code>. Then paste your referral link into the browser (e.g. <a href="http://example.test/?ref=V53YMO">http://example.test/?ref=V53YMO</a>).</p>
<p>Then imagine that we click a button on <code>example.test</code> that takes us to <code>app.example.test/register</code> for us to sign up for the application.</p>
<p>Enter details for a new user and click <code>Register</code>. If you now check out the records in the database table you should see the referred_by column for this new user contains the id of the first user you created.</p>
<p>We can create a relationship that returns users who you have referred.</p>
<p>Update <code>app/User.php</code> and add the following to the bottom of the file.</p>
<pre><code class="language-php">public function referrer()
{
    return $this-&gt;belongsTo(&#39;App\User&#39;, &#39;referred_by&#39;);
}

public function referrals()
{
    return $this-&gt;hasMany(&#39;App\User&#39;, &#39;referred_by&#39;);
}</code></pre>
<p>Then update your web.php routes file.</p>
<pre><code class="language-php">Route::get(&#39;/referrer&#39;, &#39;HomeController@referrer&#39;);
Route::get(&#39;/referrals&#39;, &#39;HomeController@referrals&#39;);</code></pre>
<p>And finally HomeController.php</p>
<pre><code class="language-php">public function referrer()
{
    return auth()-&gt;user()-&gt;referrer;
}

public function referrals()
{
    return auth()-&gt;user()-&gt;referrals;
}</code></pre>
<p>Now if you login as your first user and visit <code>app.example.test/referrals</code> you&#39;ll see an array of all the users who you&#39;ve referred to the site.</p>
<p>If you visit <code>app.example.test/referrer</code> you&#39;ll see the details of the user who referred you to the site.</p>
<p>Obviously we would never do this in a production application but things like <code>auth()-&gt;user()-&gt;referrals()-&gt;count()</code> could be useful.</p>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>This is only a very simple example but hopefully it gives you a basic idea of how a more complex system could be implemented. If you are using the same domain for marketing and registrations then you can skip all the cookie sharing stuff and keep your cookies encrypted.</p>
<p>Source code for both sites can be found here <a href="https://github.com/willbrowningme/laravel-user-referral-example">https://github.com/willbrowningme/laravel-user-referral-example</a>.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sharing Cookies with Subdomains in Laravel]]></title>
        <id>https://willbrowning.me/sharing-cookies-with-subdomains-in-laravel</id>
        <link href="https://willbrowning.me/sharing-cookies-with-subdomains-in-laravel">
        </link>
        <updated>2018-10-26T08:27:04Z</updated>
        <summary type="html"><![CDATA[Sometimes it can be useful for a subdomain such as app.example.com to have access to the cookies that are set by example.com. A situation where this could be used would be for a very simple referral tracking system, where example.com sets a cookie if there is a query string present in the URL. Then when the user registers on app.example.com this cookie is retrieved and the data regarding who referred that user is stored in the database.]]></summary>
        <content type="html"><![CDATA[<h2 id="setting-up-our-example-sites">Setting up Our Example Sites</h2>
<p>For this example I&#39;ll be using <a href="https://laravel.com/docs/5.7/homestead">Laravel Homestead</a> to set up a couple of local Laravel sites.</p>
<pre><code class="language-bash">laravel new example &amp;&amp; laravel new subdomain</code></pre>
<p>Then we need to edit Homestead.yaml and our hosts file to add addresses for these applications.</p>
<pre><code class="language-yaml">sites:
    - map: example.test
      to: /home/vagrant/code/example/public/
    - map: app.example.test
      to: /home/vagrant/code/subdomain/public/</code></pre>
<pre><code class="language-txt">192.168.10.10 example.test
192.168.10.10 app.example.test</code></pre>
<pre><code class="language-bash">homestead up --provision</code></pre>
<p>When you&#39;ve provisioned Homestead you should see the new Laravel welcome screen when you visit <code>example.test</code> and <code>app.example.test</code>.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/10/26/5bd2d2f5c7477example.test.png" alt="New Laravel App"> </p>
</div>

<h2 id="updating-our-environment-variables">Updating our Environment Variables</h2>
<p>Let&#39;s edit our <code>.env</code> file for our main example.test site. Update the following values.</p>
<pre><code class="language-env">APP_URL=http://example.test
SESSION_DOMAIN=.example.test</code></pre>
<p>The <code>SESSION_DOMAIN</code> variable is important as this will allow our subdomain to access all cookies set by the parent domain.</p>
<p>Now let&#39;s also update the <code>.env</code> file for our app.example.test site.</p>
<pre><code class="language-env">APP_URL=http://app.example.test</code></pre>
<p>We don&#39;t need to set <code>SESSION_DOMAIN</code> here.</p>
<p>We&#39;ve left <code>SESSION_DRIVER</code> as the default value which is file for both sites.</p>
<h2 id="saving-our-cookie">Saving our Cookie</h2>
<p>In our main <code>example.test</code> code update the default welcome route in <code>web.php</code>.</p>
<pre><code class="language-php">Route::get(&#39;/&#39;, function () {
    Cookie::queue(Cookie::make(&#39;test&#39;, &#39;abc&#39;, 60));

    return view(&#39;welcome&#39;);
});

Route::get(&#39;/cookie&#39;, function () {
    return Cookie::get(&#39;test&#39;);
});</code></pre>
<p>Here we&#39;re informing Laravel to set a Cookie named &#39;test&#39; with a value of &#39;abc&#39; that will expire in 60 minutes.</p>
<p>First visit <code>example.test</code> in your browser, then if you visit <code>example.test/cookie</code> you should see the value we set of <code>abc</code>. So we know that our Cookie has been succesfully set.</p>
<h2 id="accessing-our-cookie-on-our-subdomain">Accessing our Cookie on our Subdomain</h2>
<p>If you head over to your <code>app.example.test</code> code and add the following to the web.php routes file:</p>
<pre><code class="language-php">Route::get(&#39;/cookie&#39;, function () {
    return Cookie::get(&#39;test&#39;);
});</code></pre>
<p>Then visit <code>app.example.test/cookie</code> you won&#39;t be able to see anything yet as Laravel by default <a href="https://laravel.com/docs/5.7/responses#cookies-and-encryption">encrypts all cookies</a> that are set.</p>
<p>There are a couple of options we have here on how to access the cookie.</p>
<ol>
<li><strong>Use the same APP_KEY value for both sites</strong></li>
</ol>
<p>We can copy the APP_KEY value from our example.test .env file and paste it in our app.example.test .env file so that they both have the same value. If you try this and then visit again <code>app.example.test/cookie</code> you will be able to see the value <code>abc</code> and the cookie can be decrypted succsesfully. </p>
<p>The reason this works is because Laravel uses our APP_KEY value when encrypting, decrypting and signing data.</p>
<p>Some people may feel uncomfortable having the same APP_KEY value for both sites but there is another way.</p>
<ol start="2">
<li><strong>Disable encryption for the cookie in question</strong></li>
</ol>
<p>We can tell Laravel not to encrypt certain cookies if they do not contain sensitive data.</p>
<p>In <strong><code>both</code></strong> of our sites open up the <code>app/Http/Middleware</code> folder and edit the <code>EncryptCookies.php</code> file.</p>
<pre><code class="language-php">protected $except = [
    &#39;test&#39;
];</code></pre>
<p>Here we can add the name of any cookies we don&#39;t wish to be encrypted. Make sure you&#39;ve added this to <code>both sites</code>.</p>
<p>Change the value of the cookie set by <code>example.test</code> to something else so we can be sure it&#39;s working.</p>
<pre><code class="language-php">Cookie::queue(Cookie::make(&#39;test&#39;, &#39;123&#39;, 60));</code></pre>
<p>Then visit <code>example.test</code> in your browser again. Check <code>example.test/cookie</code> and you should see the value of &#39;123&#39; this time.</p>
<p>Now if you visit <code>app.example.test/cookie</code> you should be able to access the cookie and see the value of &#39;123&#39; returned.</p>
<p>You should only disable encryption for a cookie if it contains non-sensitive information.</p>
<h2 id="sharing-cookies-for-a-simple-referral-system">Sharing Cookies for a Simple Referral System</h2>
<p>I&#39;ll write another post shortly detailing how we can use what we&#39;ve applied here to create a very simple referral system that tracks who has been referred by who. The system will use middleware to determine whether to set a cookie if a certain query string is present in the request. This will enable you to link to any url on your main site like so <code>example.test/?ref=referral-id</code> or <code>example.test/pricing?ref=referral-id</code>.</p>
<p><code>Update:</code> You can find the simple referral system post here - <a href="https://willbrowning.me/building-a-simple-referral-system-in-laravel/">Building a Simple Referral System in Laravel</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clearing Your Cloudflare Cache After New Deployments]]></title>
        <id>https://willbrowning.me/clearing-your-cloudflare-cache-after-new-deployments</id>
        <link href="https://willbrowning.me/clearing-your-cloudflare-cache-after-new-deployments">
        </link>
        <updated>2018-08-07T16:10:36Z</updated>
        <summary type="html"><![CDATA[I had lost count of the number of times I've previously deployed new code to production, cleared browser cache and still been unable to see the changes. The reason being that Cloudflare was caching these files and still serving the old files. Luckily there is a really easy way to clear the cache and purge everything using the API.]]></summary>
        <content type="html"><![CDATA[<h2 id="getting-your-cloudflare-api-key">Getting your Cloudflare API key</h2>
<p>First we need to find our API key. So visit the &quot;My Profile&quot; section when logged into Cloudflare - <a href="https://dash.cloudflare.com/profile">https://dash.cloudflare.com/profile</a> at the bottom of the page you&#39;ll see your keys.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/10/23/5bcef7562b26ccloudflare-api.png" alt="Cloudflare API keys"> </p>
</div>

<p>We&#39;ll be using the Global API Key to clear the cache.</p>
<h2 id="finding-your-sites-zone-id">Finding your sites Zone ID</h2>
<p>The Zone ID for your website can be found in the &quot;Overview&quot; section for that site. It will look like this:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/10/23/5bcef944bce69cloudflare-zone-id.png" alt="Cloudflare Zone ID"> </p>
</div>

<h2 id="sending-the-api-request">Sending the API request</h2>
<p>The request we&#39;ll be sending to clear the cache looks like this:</p>
<pre><code class="language-bash">curl -X POST &quot;https://api.cloudflare.com/client/v4/zones/YOUR-ZONE-ID/purge_cache&quot; \
     -H &quot;X-Auth-Email: YOUR-CLOUDFLARE-EMAIL&quot; \
     -H &quot;X-Auth-Key: YOUR-GLOBAL-API-KEY&quot; \
     -H &quot;Content-Type: application/json&quot; \
     --data &#39;{&quot;purge_everything&quot;:true}&#39;</code></pre>
<p>Where <code>YOUR-CLOUDFLARE-EMAIL</code> is the email you use to login to Cloudflare. <code>YOUR-GLOBAL-API-KEY</code> is the key we found above and where <code>YOUR-ZONE-ID</code> is a unique identifier for your Cloudflare website.</p>
<p>You can add this code to the end of your deployment script to make sure the cache is purged after each deployment.</p>
<p>In the above example we&#39;re telling Cloudflare to purge everything but you can also choose which items to purge that have matching Cache-Tag headers or which hosts to purge although this does appear to be <code>only available for Enterprise accounts</code>.</p>
<pre><code class="language-bash">--data &#39;{
&quot;tags&quot;:[&quot;some-tag&quot;,&quot;another-tag&quot;],
&quot;hosts&quot;:[&quot;www.example.com&quot;,&quot;images.example.com&quot;]
}&#39;</code></pre>
<p>More documentation can be found here - <a href="https://api.cloudflare.com/#zone-purge-files-by-cache-tags-or-host">https://api.cloudflare.com/#zone-purge-files-by-cache-tags-or-host</a></p>
<p>If everything went to plan you should get a response from Cloudflare like so:</p>
<pre><code class="language-bash">{
  &quot;success&quot;: true,
  &quot;errors&quot;: [],
  &quot;messages&quot;: [],
  &quot;result&quot;: {
    &quot;id&quot;: &quot;9a7806061c88ada191ed06f989cc3dac&quot;
  }
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Reducing the Vendor Bundle Size in Nuxt.js]]></title>
        <id>https://willbrowning.me/reducing-the-vendor-bundle-size-in-nuxt-js</id>
        <link href="https://willbrowning.me/reducing-the-vendor-bundle-size-in-nuxt-js">
        </link>
        <updated>2018-07-03T14:39:24Z</updated>
        <summary type="html"><![CDATA[When running Nuxt's "npm run generate" command I kept getting a warning stating that the javascript vendor bundle was too big on my static blog and that it was above the recommended 300kB size limit. Let's have a look at trying to reduce the size of it!]]></summary>
        <content type="html"><![CDATA[<p>The warning in question looks like this:</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/07/03/5b3b8772f2991vendor-warning-nuxt.png" alt="Vendor Warning"> </p>
</div>

<p>Our vendor bundle is coming in at 752kB!</p>
<h2 id="identifying-the-main-culprits">Identifying the Main Culprits</h2>
<p>First things first we need to find out why our vendor bundle is so big in the first place.</p>
<p>Luckily Nuxt uses <a href="webpack-bundle-analyzer">webpack-bundle-analyzer</a> so we can simply add the following to our <code>nuxt.config.js</code> under the build property.</p>
<pre><code class="language-javascript">build: {
  analyze: true,
}</code></pre>
<p>Then when you run <code>npm run generate</code> it will open up the build analyser at <code>http://127.0.0.1:8888</code>.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/07/03/5b3b8641cc701build-analyser.png" alt="Build Analyser"> </p>
</div>

<p>Looking at this we can see the <code>highlight.js</code> package is very big with a parsed size of 540kB!</p>
<p>If we inspect this further we can see this is mainly due to a few languages included with it like mathematica.js or sqf.js.</p>
<p>Now in my case I only use a handful of common languages so I don&#39;t need any of the other included ones.</p>
<h2 id="including-only-highlightjs-languages-we-need">Including Only Highlight.js Languages We Need</h2>
<p>After a little bit of searching I came across <a href="https://github.com/isagalaev/highlight.js/issues/1257#issuecomment-254504876">this comment</a> on GitHub on how to acheive this.</p>
<p>So let&#39;s give it a try and update our Nuxt site.</p>
<p>I have a <code>filters.js</code> in the plugins directory where I was importing highlight.js.</p>
<p>I updated the import to the following: (I was previously doing <code>import hljs from &#39;highlight.js&#39;</code>)</p>
<pre><code class="language-javascript">import hljs from &#39;highlight.js/lib/highlight.js&#39;</code></pre>
<p>Then simply specify which languages you want to register like so:</p>
<pre><code class="language-javascript">hljs.registerLanguage(&#39;php&#39;, require(&#39;highlight.js/lib/languages/php&#39;))
hljs.registerLanguage(&#39;javascript&#39;, require(&#39;highlight.js/lib/languages/javascript&#39;))
hljs.registerLanguage(&#39;css&#39;, require(&#39;highlight.js/lib/languages/css&#39;))</code></pre>
<p>Make sure to only add the languages that you intend to use.</p>
<h2 id="also-update-highlightjs-in-build--vendor">Also Update Highlight.js In Build &gt; Vendor</h2>
<p>I also had <code>Highlight.js</code> in the vendor file importing all of the languages, so I simply updated this aswell:</p>
<pre><code class="language-javascript">build: {
  vendor: [&#39;axios&#39;, &#39;highlight.js/lib/highlight.js&#39;],
  analyze: true,
}</code></pre>
<div class="blog-note">
    <b>Note: </b> The vendor array has been deprecated in Nuxt 2.0
</div>

<p>Then ran <code>npm run generate</code> again and had a look at the build analyser.</p>
<h2 id="the-result">The Result</h2>
<p>This time the vendor bundle was only 226kB in parsed size, down from 752kB! That&#39;s a 70% decrease just from removing uneeded languages. </p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/07/03/5b3b8b4fd4f28build-analyser-after.png" alt="Build Analyser"> </p>
</div>

<p>As you can see we reduced the Highlight.js package down to 31.53kB from 540kB.</p>
<p>And since our vendor bundle is now less than 300kB we no longer get the annoying warning in our terminal. <code>Success</code>!</p>
<p>Another example we can use is with moment.js, which is usually overkill if you are only doing some basic date formatting.</p>
<p>Another library that is much more lightweight and has a similar API is <a href="https://github.com/iamkun/dayjs">day.js</a>.</p>
<p>If we remove moment.js and run <code>npm install dayjs --save</code> to replace it with day.js then we can simply do the following:</p>
<pre><code class="language-javascript">const dayjs = require(&#39;dayjs&#39;)
import advancedFormat from &#39;dayjs/plugin/advancedFormat&#39;
dayjs.extend(advancedFormat)

Vue.filter(&#39;toDate&#39;, function(timestamp) {
  return dayjs(timestamp*1000).format(&#39;Do MMM YY&#39;)
})</code></pre>
<p>The reason we needed to import the advancedFormat plugin for day.js is simply because &#39;Do&#39; is not included in the default day.js installation.</p>
<p>We can now format dates in the same way as with moment but using a much smaller library.</p>
<p>I&#39;ll try to add more examples here in the future.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Setting up Automatic Deployment and Builds Using Webhooks]]></title>
        <id>https://willbrowning.me/setting-up-automatic-deployment-and-builds-using-webhooks</id>
        <link href="https://willbrowning.me/setting-up-automatic-deployment-and-builds-using-webhooks">
        </link>
        <updated>2018-06-26T14:09:53Z</updated>
        <summary type="html"><![CDATA[This post demonstrates a reasonably simple way to automatically deploy and run code builds for your sites using webhooks and GitHub (you can use GitLab or whatever your preference is). We will create a webhook that is fired when we push updates to our origin repository and then use an incoming webhook server to listen for these and to fetch our updates then run our build scripts.]]></summary>
        <content type="html"><![CDATA[<h2 id="installing-our-incoming-webhook-server">Installing our Incoming Webhook Server</h2>
<p>We&#39;ll be using the following incoming webhook server to acheive our goal - <a href="https://github.com/adnanh/webhook">https://github.com/adnanh/webhook</a></p>
<p>This webhook server is written in Go and is really simply to get set up. It is easy to configure as the config file is just JSON.</p>
<p>I&#39;ll be spinning up a fresh droplet with DigitalOcean for this example but you can use your own existing server and websites.</p>
<p>We could use this process to test in a staging environment but for this post we&#39;ll just be keeping it simple.</p>
<p>I&#39;ll be running all commands in this post as a user <code>johndoe</code> with sudo permissions.</p>
<p>If you intend to run any npm commands in your build script make sure you have nodejs installed on your server.</p>
<p>The first thing we need to do is install golang on our server so that we can then install the incoming webhook server. You can do so using the following commands, make sure to find the latest stable version from the list here - <a href="https://golang.org/dl/">https://golang.org/dl/</a></p>
<p>e.g. <code>go1.10.3.linux-amd64.tar.gz</code></p>
<pre><code class="language-bash">cd ~
wget https://dl.google.com/go/go&lt;VERSION&gt;.&lt;OS&gt;-&lt;ARCH&gt;.tar.gz 
sudo tar -C /usr/local -xzf go&lt;VERSION&gt;.&lt;OS&gt;-&lt;ARCH&gt;.tar.gz 
export PATH=$PATH:/usr/local/go/bin</code></pre>
<p>Then we can simply install the latest version of webhook with the following command:</p>
<pre><code class="language-bash">go get github.com/adnanh/webhook</code></pre>
<p>This will create a file <code>~/go/bin/webhook</code>, in my case <code>/home/johndoe/go/bin/webhook</code>.</p>
<h2 id="configuring-our-webhooks">Configuring our Webhooks</h2>
<p>Create a folder called <code>~/hooks</code> and then create a folder inside hooks with the same name as the website your going to deploy. In my case I&#39;ll just call it <code>my-site-1</code>. This is where we&#39;ll put our <code>deploy.sh</code> script and also an <code>output.log</code> file.</p>
<pre><code class="language-bash">mkdir ~/hooks
mkdir ~/hooks/my-site-1</code></pre>
<p>Now create a new file inside the hooks directory and add following inside JSON inside, make sure to change my-site-1 to the name of your site and also change the command-working-directory to the correct root directory of your site: </p>
<pre><code class="language-bash">nano ~/hooks/hooks.json</code></pre>
<pre><code class="language-json">[
  {
    &quot;id&quot;: &quot;deploy-my-site-1&quot;,
    &quot;execute-command&quot;: &quot;/home/johndoe/hooks/my-site-1/deploy.sh&quot;,
    &quot;command-working-directory&quot;: &quot;/var/www/my-site-1/&quot;,
    &quot;response-message&quot;: &quot;Executing deploy script...&quot;,
     &quot;trigger-rule&quot;:
    {
      &quot;and&quot;:
      [
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;payload-hash-sha1&quot;,
            &quot;secret&quot;: &quot;&lt;RANDOM-SECRET-STRING&gt;&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;header&quot;,
              &quot;name&quot;: &quot;X-Hub-Signature&quot;
            }
          }
        },
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;value&quot;,
            &quot;value&quot;: &quot;refs/heads/master&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;payload&quot;,
              &quot;name&quot;: &quot;ref&quot;
            }
          }
        }
      ]
    }
  }
]</code></pre>
<p>Replace <RANDOM-SECRET-STRING> with a long random string e.g. H4GMvnc3v^fiK#r3qJMTTsk%ZL4Hdq we will need to use this later in GitHub when setting up the webhook.</p>
<p>Inside the <code>~/hooks/my-site-1</code> folder create an <code>output.log</code> file. Then create a file named <code>deploy.sh</code>.</p>
<pre><code class="language-bash">cd ~/hooks/my-site-1
touch output.log
touch deploy.sh
chmod +x deploy.sh</code></pre>
<p>The chmod command simply makes the .sh file executable.</p>
<p>Add the following inside deploy.sh (update to suit your sites needs):</p>
<pre><code class="language-bash">#!/usr/bin/env bash
# redirect stdout/stderr to a file
exec &gt; /home/johndoe/hooks/my-site-1/output.log 2&gt;&amp;1

git fetch --all

git checkout --force &quot;origin/master&quot;

npm install --production

npm run production

composer install --no-dev

php artisan route:cache

php artisan config:cache

php artisan view:cache

php artisan queue:restart</code></pre>
<p>The third line of the above simply redirects all output to our <code>output.log</code> file. Then we run git fetch and get checkout to get our code updates from our origin repo (in my case GitHub).</p>
<p>You can update the other commands to suit your needs. Since I&#39;m using a <code>Laravel</code> app as an example I&#39;ll run some artisan commands to clear the cache and restart the queue etc.</p>
<p>The incoming webhook server runs on <code>port 9000</code> by default you can change this if you wish as described <a href="https://github.com/adnanh/webhook/blob/master/docs/Webhook-Parameters.md">here</a> but for our example we&#39;ll just leave it.</p>
<p>You now need to make sure that port 9000 is open on your server, which may involve updating your firewall rules. If you&#39;re using a service such as <a href="https://runcloud.io/r/BVrWyymBWKNk">RunCloud</a> (affiliate link) this is very easily done from the user interface.</p>
<p>Once you&#39;ve made sure port 9000 is open we can try running the server to see if everything is working so far.</p>
<h2 id="starting-up-our-webhook-server">Starting up our Webhook Server</h2>
<p>To start the server enter the following command making sure to change johndoe to your user&#39;s username and <YOUR-SERVER-IP> with the IP of the your server.</p>
<pre><code class="language-bash">/home/johndoe/go/bin/webhook -hooks /home/johndoe/hooks/hooks.json -ip &quot;&lt;YOUR-SERVER-IP&gt;&quot; -verbose</code></pre>
<p>If you now visit <code>http://&lt;YOUR-SERVER-IP&gt;:9000/hooks/deploy-my-site-1</code> in the browser you should see a message saying <code>Hook rules were not satisfied.</code> This is because the rules we specified in hooks.json including the secret string were not included in our request and therefore not satisfied.</p>
<p>Stop the webhook server by typing CTRL+C in the terminal.</p>
<p>Go to your sites web root on your server and initialise a git repository, then add your remote GitHub url.</p>
<pre><code class="language-bash">cd /var/www/my-site-1
git init
git remote add origin git@my-site-1:willbrowningme/my-site-1.git</code></pre>
<p>The reason we use the above as the remote origin url is so that we can use an alias in our <code>~/.ssh/config</code> file to specify which ssh key to use when connecting. Update my-site-1 to the name of your repo. If you are using GitLab or another service that allows multiples repos per key then you can have the above as <code>git@github.com:willbrowningme/my-site-1.git</code>.</p>
<div class="blog-note">
    <b>Note: </b> The alias is needed when using GitHub if you want to have multiple deploy scripts on your server since GitHub only allows one unique Deploy Key per repository.
</div>

<p>In <code>~/.ssh/</code> create a new file called config and add the following inside:</p>
<p>If the .ssh directory doesn&#39;t exist yet then simply create it by running <code>mkdir ~/.ssh</code>.</p>
<pre><code class="language-bash">nano ~/.ssh/config</code></pre>
<pre><code class="language-bash"># My Site 1 Repo
Host my-site-1 github.com
HostName github.com
IdentityFile ~/.ssh/my_site_1_id_rsa</code></pre>
<p>Make sure to change my-site-1 to the alias you definied above for the remote branch and also the IdentityFile to the path for the private key we are about to generate.</p>
<p>If we try to now run <code>git fetch -all</code> we will get an error saying Permission denied (publickey). This is because we haven&#39;t yet set up a deploy key for the repo in GitHub.</p>
<h2 id="generating-our-deploy-key">Generating our Deploy Key</h2>
<p>To fix this let&#39;s generate a new ssh key paid on our server by running. Substitute the email for your GitHub email.</p>
<p>When it asks <code>Enter a file in which to save the key</code> name it like so - <code>/home/johndoe/.ssh/my_site_1_id_rsa</code> and leave the passphrase blank. (replace my_site_1 with the name of your github repo)</p>
<pre><code class="language-bash">ssh-keygen -t rsa -b 4096 -C &quot;your@github-email.com&quot;</code></pre>
<p>Again, the reason we are doing this is because GitHub only allows one deploy key to be used for each repository. You cannot use the same key for multiple repositories. Hence the naming convention.</p>
<p>I beleive GitLab does allow you to use it for multiple repos so you can just leave the name as default <code>id_rsa</code> in that case if you wish.</p>
<p>Now we need to copy the public key and add it to GitHub as a <code>deploy key</code>. So open up the pub key file.</p>
<pre><code class="language-bash">vi ~/.ssh/my_site_1_id_rsa.pub</code></pre>
<p>Copy the contents of this file and then type <code>:q</code> to quit the vim editor.</p>
<p>On GitHub go to the repo in question click on settings and then <code>Deploy Keys</code>. Click &quot;add deploy key&quot; and paste in the contents of your public key we just generated.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/07/02/5b3a2715d43f5github-deploy-key.png" alt="GitHub Deploy Key"></p>
</div>

<p>Now back in your websites web root and try to run the following again.</p>
<pre><code class="language-bash">cd /var/www/my-site-1
git fetch --all
git checkout --force &quot;origin/master&quot;</code></pre>
<p>With any luck the commands should work correctly now.</p>
<p>In the GitHub repo go to settings then webhooks and click &quot;add a webhook&quot;. For the payload url enter <code>http://&lt;YOUR-SERVER-IP&gt;:9000/hooks/deploy-my-site-1</code> replacing your server IP and the ID you gave in hooks.json for the webhook.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/07/02/5b3a25f91d383github-webhook.png" alt="GitHub Webhook"></p>
</div>

<p>Choose application/json for the content type and make sure to enter the random secret string you generated ealier in our hooks.json file. These will need to match or the script will not be exectuted. Choose &quot;just the push event&quot; and save the webhook.</p>
<h2 id="testing-it-works">Testing it Works</h2>
<p>Now we need to test it all works as planned. So start up your webhook server again by running:</p>
<pre><code class="language-bash">/home/johndoe/go/bin/webhook -hooks /home/johndoe/hooks/hooks.json -ip &quot;&lt;YOUR-SERVER-IP&gt;&quot; -verbose</code></pre>
<p>Make an edit or an update to your code on your local pc repository so that we can commit the changes and then push them to GitHub by running:</p>
<pre><code class="language-bash">git push origin master</code></pre>
<p>This should now trigger GitHub to send the webhook delivery to our server which will then run the <code>deploy.sh</code> script for my-site-1 and will fetch the updates we just made and then build the site with the commands we gave.</p>
<p>If you visit GitHub settings and then webhooks you should see the new delivery under <code>Recent Deliveries</code>. Make sure it has a <code>200</code> response code and shows the response body we gave of &quot;Executing deploy script...&quot;.</p>
<p>Stop the webhook server by typing CTRL+C into the terminal.</p>
<h2 id="installing-supervisor-to-keep-our-webhook-server-running">Installing Supervisor to Keep our Webhook Server Running</h2>
<p>Now that everything is working as planned let&#39;s install <code>supervisor</code> so we can keep the webhook server running in the background.</p>
<p>So below we install supervisor then create a new .conf file inside the <code>/etc/supervisor/conf.d</code> directory.</p>
<pre><code class="language-bash">sudo apt install supervisor
cd /etc/supervisor/conf.d
sudo nano webhooks.conf</code></pre>
<p>Add the following inside the <code>webhooks.conf</code> file, replacing the username and IP etc. with your values.</p>
<pre><code class="language-bash">[program:webhooks]
command=bash -c &quot;/home/johndoe/go/bin/webhook -hooks /home/johndoe/hooks/hooks.json -ip &#39;&lt;YOUR-SERVER-IP&gt;&#39; -verbose&quot;
redirect_stderr=true
autostart=true
autorestart=true
user=johndoe
numprocs=1
process_name=%(program_name)s_%(process_num)s
stdout_logfile=/home/johndoe/hooks/supervisor.log
environment=HOME=&quot;/home/johndoe&quot;,USER=&quot;johndoe&quot;</code></pre>
<p>Save this file and then run.</p>
<pre><code class="language-bash">touch ~/hooks/supervisor.log
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start webhooks:*</code></pre>
<p>I had a lot of issues with the webhooks.conf file and getting supervisor to start the server as the non root user. Initially it kept running the server as root which would then cause all the npm and git commands inside <code>deploy.sh</code> to fail. </p>
<p>However I managed to get it working correctly by setting the right environment variables and then running the command through <code>bash -c &quot;the-command-here&quot;</code>.</p>
<p>So now we should have the webhooks server running nicely in the background ready to receive incoming deliveries from GitHub.</p>
<p>Make another edit to your local code and push it to GitHub to make sure everything is still working as it should.</p>
<p>Check the <code>output.log</code> file at <code>~/hooks/my-site-1/output.log</code> to see the output from <code>deploy.sh</code>.</p>
<h2 id="adding-another-site">Adding Another Site</h2>
<p>If you want to add another site with a different set of deploy and build commands you can follow these steps:</p>
<p>First let&#39;s edit hooks.json so that it looks something like this:</p>
<pre><code class="language-json">[
  {
    &quot;id&quot;: &quot;deploy-my-site-1&quot;,
    &quot;execute-command&quot;: &quot;/home/johndoe/hooks/my-site-1/deploy.sh&quot;,
    &quot;command-working-directory&quot;: &quot;/var/www/my-site-1/&quot;,
    &quot;response-message&quot;: &quot;Executing deploy script...&quot;,
     &quot;trigger-rule&quot;:
    {
      &quot;and&quot;:
      [
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;payload-hash-sha1&quot;,
            &quot;secret&quot;: &quot;&lt;RANDOM-SECRET-STRING&gt;&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;header&quot;,
              &quot;name&quot;: &quot;X-Hub-Signature&quot;
            }
          }
        },
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;value&quot;,
            &quot;value&quot;: &quot;refs/heads/master&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;payload&quot;,
              &quot;name&quot;: &quot;ref&quot;
            }
          }
        }
      ]
    }
  },
  {
    &quot;id&quot;: &quot;deploy-my-site-2&quot;,
    &quot;execute-command&quot;: &quot;/home/johndoe/hooks/my-site-2/deploy.sh&quot;,
    &quot;command-working-directory&quot;: &quot;/var/www/my-site-2/&quot;,
    &quot;response-message&quot;: &quot;Executing deploy script...&quot;,
     &quot;trigger-rule&quot;:
    {
      &quot;and&quot;:
      [
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;payload-hash-sha1&quot;,
            &quot;secret&quot;: &quot;&lt;RANDOM-SECRET-STRING&gt;&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;header&quot;,
              &quot;name&quot;: &quot;X-Hub-Signature&quot;
            }
          }
        },
        {
          &quot;match&quot;:
          {
            &quot;type&quot;: &quot;value&quot;,
            &quot;value&quot;: &quot;refs/heads/master&quot;,
            &quot;parameter&quot;:
            {
              &quot;source&quot;: &quot;payload&quot;,
              &quot;name&quot;: &quot;ref&quot;
            }
          }
        }
      ]
    }
  }
]</code></pre>
<p>We then need to add a new folder called my-site-2 and then a new file called <code>deploy.sh</code>, making sure to change the output file too.</p>
<pre><code class="language-bash">mkdir ~/hooks/my-site-2
touch ~/hooks/my-site-2/output.log
nano ~/hooks/my-site-2/deploy.sh</code></pre>
<p>Inside our new deploy.sh file add the following:</p>
<pre><code class="language-bash">#!/usr/bin/env bash
# redirect stdout/stderr to a file
exec &gt; /home/johndoe/hooks/my-site-2/output.log 2&gt;&amp;1

git fetch --all

git checkout --force &quot;origin/master&quot;

npm install --production

npm run production

composer install --no-dev

php artisan route:cache

php artisan config:cache

php artisan view:cache

php artisan queue:restart</code></pre>
<p>Remember to make it executable too.</p>
<pre><code class="language-bash">chmod +x ~/hooks/my-site-2/deploy.sh</code></pre>
<p>Then we need to generate a new key pair named my_site_2_id_rsa and add the public key to the <code>deploy key</code> section in the github repo just like we did earlier.</p>
<p>So initialise a new git repo (if you haven&#39;t got one already) and add the corresponding remote origin url to your code in <code>/var/www/my-site-2</code> (or wherever you site is located).</p>
<pre><code class="language-bash">cd /var/www/my-site-2
git init
git remote add origin git@my-site-2:willbrowningme/my-site-2.git</code></pre>
<p>Then update ~/.ssh/config</p>
<pre><code class="language-bash"># My Site 1 Repo
Host my-site-1 github.com
HostName github.com
IdentityFile ~/.ssh/my_site_1_id_rsa

# My Site 2 Repo
Host my-site-2 github.com
HostName github.com
IdentityFile ~/.ssh/my_site_2_id_rsa</code></pre>
<p>Test using git fetch</p>
<pre><code class="language-bash">git fetch --all
git checkout --force &quot;origin/master&quot;</code></pre>
<p>If all went well the git fetch command should have worked.</p>
<p>Next make sure to restart the supervisor job as we have updated the hooks file.</p>
<pre><code class="language-bash">sudo supervisorctl reload</code></pre>
<p>Now make an edit on your local repo of the your second project and test pushing the changes to origin.</p>
<p><code>Success!</code> You should now be set up with automatic deployments and builds for the sites.</p>
<p>If you can see a way to improve on this setup then please let me know in the comments.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 3:  Deployment]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment">
        </link>
        <updated>2018-06-21T12:04:18Z</updated>
        <summary type="html"><![CDATA[In this post we'll look at adding a few finishing touches to the site and then at how we can go about deploying it. Including setting up automatic regeneration for the site when a post is updated, added or removed.]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Parts 1 and 2 of this guide you can find them here - <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a> and here - <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></p>
<p>Before we look at deploying our static blog let&#39;s add a few finishing touches like a sitemap and page titles etc.</p>
<h2 id="adding-a-sitemap">Adding a Sitemap</h2>
<p>In the project root run the following to install the Nuxt Community sitemap module:</p>
<pre><code class="language-bash">npm install @nuxtjs/sitemap --save-dev</code></pre>
<p>Then in your nuxt.config.js add the sitemap to the modules: property</p>
<pre><code class="language-javascript">modules: [
  // Doc: https://github.com/nuxt-community/axios-module#usage
  &#39;@nuxtjs/axios&#39;,
  &#39;@nuxtjs/sitemap&#39;
],</code></pre>
<p>Then still in nuxt.config.js add the following code below the generate: property</p>
<pre><code class="language-javascript">sitemap: {
  path: &#39;/sitemap.xml&#39;,
  hostname: process.env.URL,
  cacheTime: 1000 * 60 * 15,
  generate: true, // Enable me when using nuxt generate
  async routes () {
    let { data } = await axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })

    const collection = collect(data.entries)

    let tags = collection.map(post =&gt; post.tags)
    .flatten()
    .unique()
    .map(tag =&gt; `category/${tag}`)
    .all()

    let posts = collection.map(post =&gt; post.title_slug).all()

    return posts.concat(tags)
  }
},</code></pre>
<p>Here we are simply letting the sitemap module know what routes we have.</p>
<h2 id="setting-page-titles-and-meta">Setting Page Titles and Meta</h2>
<p>When we deploy our site we want to have the correct page titles and meta descriptions for each post, so let&#39;s look at sorting this out.</p>
<p>In the head: {...} property of nuxt.config.js you&#39;ll see we have a title and meta property we can set. Set these to the default for your blog.</p>
<p>Lets look at our about.vue page we created in the first part of this guide. If you don&#39;t have one just create a new <code>about.vue</code> file in the pages directory and add the following:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section class=&quot;my-8&quot;&gt;
    &lt;div class=&quot;text-center&quot;&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;About Page&lt;/h1&gt;
      &lt;p&gt;
        Hi this is a static blog made with Nuxt.js, Cockpit and Tailwindcss!
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  head () {
    return {
      title: &#39;About&#39;,
      meta: [
        { hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;This is the about page!&#39; }
      ]
    }
  }
}
&lt;/script&gt;</code></pre>
<p>Note the <code>hid</code> property, if we are declaring the same meta tags as in our nuxt.config.js we need include this so that Nuxt does not duplicate the meta tags. Instead it overides those in nuxt.config.js with the ones we add here with the same <code>hid</code> value.</p>
<p>But what about in our dynamic post and category pages? </p>
<p>Open up your <code>_title_slug.vue</code> page and add the following beneath the asyncData method:</p>
<pre><code class="language-javascript">head () {
  return {
    title: this.post.title,
    meta: [
      { hid: &#39;description&#39;, name: &#39;description&#39;, content: this.post.excerpt },
    ]
  }
}</code></pre>
<p>You can run the dev server and make sure everything is working correctly and the page titles are being set.</p>
<p>Do the same for <code>_tag.vue</code> in the category directory.</p>
<pre><code class="language-javascript">head () {
  return {
    title: `Posts tagged with ${this.category}`,
    meta: [
      { hid: &#39;description&#39;, name: &#39;description&#39;, content: `All blog posts categorised as ${this.category}.` },
    ]
  }
}</code></pre>
<p>If you want to improve this further you can add meta tags for social media sites like Twitter, Google and Facebook.</p>
<p>Also using <a href="https://realfavicongenerator.net/">Real Favicon Generator</a> you can create all the correct icons etc. Just add the files to your static directory and they will be copied over to the dist directory when you run <code>npm run generate</code>.</p>
<h2 id="displaying-our-post-dates">Displaying our Post Dates</h2>
<p>So far we haven&#39;t displayed the creation date for any of our blog posts so let&#39;s look at how we can do this.</p>
<p>Install <a href="https://github.com/iamkun/dayjs">day.js</a> with the following command:</p>
<pre><code class="language-bash">npm install dayjs --save-dev</code></pre>
<p>We&#39;re using dayjs as we only want to do some simple date formatting and moment.js is overkill for this situation.</p>
<p>Once installed open up the filters.js file in the plugins directory and update it so that it looks like this:</p>
<pre><code class="language-javascript">import Vue from &#39;vue&#39;
import highlightjs from &#39;highlight.js&#39;
import marked, { Renderer } from &#39;marked&#39;
const dayjs = require(&#39;dayjs&#39;)
import advancedFormat from &#39;dayjs/plugin/advancedFormat&#39;
dayjs.extend(advancedFormat)

// Only import the languages that you need to keep our js bundle small
highlightjs.registerLanguage(&#39;php&#39;, require(&#39;highlight.js/lib/languages/php&#39;))
highlightjs.registerLanguage(&#39;javascript&#39;, require(&#39;highlight.js/lib/languages/javascript&#39;))
highlightjs.registerLanguage(&#39;css&#39;, require(&#39;highlight.js/lib/languages/css&#39;))

// Create your custom renderer.
const renderer = new Renderer()
renderer.code = (code, language) =&gt; {
  // Check whether the given language is valid for highlight.js.
  const validLang = !!(language &amp;&amp; highlightjs.getLanguage(language))
  // Highlight only if the language is valid.
  const highlighted = validLang ? highlightjs.highlight(language, code).value : code
  // Render the highlighted code with `hljs` class.
  return `&lt;pre&gt;&lt;code class=&quot;hljs ${language}&quot;&gt;${highlighted}&lt;/code&gt;&lt;/pre&gt;`
}

// Set the renderer to marked.
marked.setOptions({ renderer })

Vue.filter(&#39;parseMd&#39;, function(content) {
    return marked(content)
})

Vue.filter(&#39;toDate&#39;, function(timestamp) {
  return dayjs(timestamp*1000).format(&#39;Do MMM YY&#39;)
})</code></pre>
<p>We needed to import <code>advancedFormat</code> since the <code>Do</code> date format is not included in dayjs by default. If you want to format you dates differently you might not need this.</p>
<p>Cockpit returns our created date as a timestamp in seconds, so we need to multiply it by 1000 to get it into milliseconds. Then we just format it to our liking.</p>
<p>You can now go and update <code>index.vue</code>, <code>_tag.vue</code> and <code>_title_slug.vue</code> to include the post&#39;s created date like so <code>{{ post._created | toDate }}</code>.</p>
<p>Your site should now look something like this.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/21/5b2b9e362f627posts-with-dates.png" alt="Posts with dates"> </p>
</div>

<h2 id="deploying-the-site">Deploying the Site</h2>
<p>Now that our site is in reasonable shape let&#39;s look at deploying it.</p>
<p>By far the easiest place for us to deploy our site is <a href="https://www.netlify.com/">Netlify</a>.</p>
<p>We can simply link our git repository on GitHub/GitLab/Bitbucket and it will automatically be updated and rebuilt on Netlify whenever we push changes. We can also easily add webhooks that allow us to tell Netlify to regenerate the site when we update one of our blog posts in Cockpit.</p>
<p>Just before we do this we need to add a little script to the root of our site that will allow Netlify to create a .env file at the time it builds our site.</p>
<p>The reason we need to do this is because we added our .env file to our .gitignore file so it won&#39;t be committed to git and Netlify won&#39;t have access to our Cockpit API key!</p>
<p>So create a new file called <code>create-env.js</code> and add the following to it:</p>
<pre><code class="language-javascript">const fs = require(&#39;fs&#39;)
fs.writeFileSync(&#39;./.env&#39;, `
BASE_URL=${process.env.BASE_URL}\n
POSTS_URL=${process.env.POSTS_URL}\n
URL=${process.env.URL}
`)</code></pre>
<p>All this little script does is create a .env file from the <code>Build environment variables</code> that we will set up in Netlify soon.</p>
<p>If you haven&#39;t already initialise a git repository for your site and then push it to whichever service you use (e.g. GitHub).</p>
<p>Sign up at <a href="https://www.netlify.com/">Netlify</a> (it&#39;s free) and add a new site from git.</p>
<p>When you&#39;ve allowed Netlify access and selected the correct git repository you need to add the following under <code>Deploy Settings</code> as the Build command: </p>
<pre><code class="language-bash">node ./create-env.js &amp;&amp; npm run generate</code></pre>
<p>Remember to set the <code>Publish directory</code> as dist.</p>
<p>This tells Netlify to run our <code>create-env.js</code> script above and write to a .env file so we can use our Cockpit API key etc.</p>
<p>Finally we need to tell Netlify what our <code>Build environment variables</code> are so click &quot;new variable&quot; until you have something like this.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2019/03/07/5c8133450e106netlify-environment-variables.png" alt="Build Environment Variables"> </p>
</div>

<p>Now with any luck you&#39;ll be able to push changes to GitHub etc and Netlify will automatically be notified of the changes and rebuild your site by running the <code>npm run generate</code> command we specified above!</p>
<div class="blog-note">
    <b>Note:</b> If you run into errors or issues during the build phase with Netlify try changing the Build image
</div>

<h2 id="setting-up-build-webhooks">Setting up Build Webhooks</h2>
<p>So we&#39;ve got automatic deploys set up for pushing changes to GitHub etc. but now we need to tell Netlify to rebuild of static site when we update, add or delete a post in Cockpit.</p>
<p>In Netlify under &quot;Build &amp; Deploy&quot; Settings you should see an option to add a build hook.</p>
<p>Click on this and call it something like <code>Regenerate Blog</code>.</p>
<p>You should then see a URL like this <code>https://api.netlify.com/build_hooks/xxxxxxxxxxxxxxxx</code> copy this URL and then head over to your Cockpit backend - <code>https://cms.yourdomain.com</code>.</p>
<p>Once signed into Cockpit go to settings, webhooks and click &quot;create a webhook&quot;. Call the webhook Regenerate Blog or anything like that and paste in your Netlify Build Hook URL.</p>
<p>Make sure to add events <code>collections.save.after</code> and <code>collections.remove.after</code>.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/21/5b2ba870d45a5cockpit-webhook.png" alt="Build Environment Variables"> </p>
</div>

<p>Click save and then go edit one of your posts to see if everything is working.</p>
<p>You should see after a minute or so that Netlify has automatically regenerated the static site for us!</p>
<p>You can now go on to add your own custom domain to your blog and also add an SSL certifcate with forced https redirection.</p>
<h2 id="deploying-without-using-netlify">Deploying without using Netlify</h2>
<p>We could also create a similar setup to the above on our own Digitalocean, Vultr etc. VPS using a small server to accept webhooks and run shell commands. <code>I&#39;ll cover this in a future post!</code></p>
<p><code>Update!</code> You can find my post explaining this here - <a href="https://willbrowning.me/setting-up-automatic-deployment-and-builds-using-webhooks">Setting up Automatic Deployment and Builds Using Webhooks</a></p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Hopefully you can see how easy it is to get up and running with a simple statically generate site using Nuxt and Cockpit. Paired with Netlify it really is a great developer experience and being served on Netlify&#39;s CDN makes it extremely fast!</p>
<p>You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here</a> and see a live demo of the site on Netlify here - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 2:  Dynamic Routes]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">
        </link>
        <updated>2018-06-18T13:23:39Z</updated>
        <summary type="html"><![CDATA[In this post we'll be setting up our category page to display all posts that have a tag matching our category. We'll also be setting up our dynamic routes so that when we run "npm run generate" all the individual post and category routes will be correctly generated.]]></summary>
        <content type="html"><![CDATA[<p>If you haven&#39;t read Part 1 of this guide you can find it here - <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup/">Part 1: Setup</a></p>
<h2 id="generating-our-dynamic-routes-for-individual-blog-posts">Generating our dynamic routes for individual blog posts</h2>
<p>You might be wondering how can we generate static pages for each blog post when deploying or updating our site?</p>
<p>Nuxt comes with an easy solution for this, so open up your nuxt.config.js and add the following above the build: {...} property:</p>
<pre><code class="language-javascript">generate: {
  routes: async () =&gt; {
    let { data } = await axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })
    return data.entries.map((post) =&gt; {
      return {
        route: post.title_slug,
        payload: post
      }
    })
  }
},</code></pre>
<p>So what&#39;s going on here? Well first we make a call to our Cockpit backend to get our post entries. We then map this response into an object containing the actual <code>route</code> (we&#39;re using the title slug for this) and also a <code>payload</code> object.</p>
<p>The payload we set to the entire post entry. This will be passed to each generated blog post and we&#39;ll be able to access it and display the contents.</p>
<p>This makes generating our static site faster as we won&#39;t need to fetch each blog post individually from every blog post page we generate.</p>
<p>You can read more about this at <a href="https://nuxtjs.org/api/configuration-generate#speeding-up-dynamic-route-generation-with-code-payload-code-">Nuxtjs.org.</a></p>
<p>So now we&#39;ve told our blog what routes it needs to have we need to create a page that will display the contents of individual blog posts.</p>
<p>The convention for dynamic pages in Nuxt is to name the page like so <code>_title_slug.vue</code> where title_slug is the unique route identifier in our case. Notice also we have prefixed title_slug with an underscore.</p>
<p>So create a new file called <code>_title_slug.vue</code> in the pages directory. If you want your links to be /blog/title_slug instead of just /title_slug then you need to create a blog directory in the pages directory then put <code>_title_slug.vue</code> in there. You can of course use /post/title_slug or whatever you like.</p>
<p>Inside the newly created <code>_title_slug.vue</code> file add this code:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;article class=&quot;my-8&quot;&gt;
      &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
        &lt;a v-for=&quot;(tag, key) in post.tags&quot; :key=&quot;key&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
      &lt;/div&gt;
      &lt;h1 class=&quot;mt-2 text-3xl font-bold&quot;&gt;
        {{ post.title }}
      &lt;/h1&gt;
      &lt;div class=&quot;mt-4 markdown&quot; v-html=&quot;post.excerpt + &#39;\n&#39; + post.content&quot;&gt;
      &lt;/div&gt;
    &lt;/article&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  async asyncData ({ app, params, error, payload }) {
    if (payload) {
      return { post: payload }
    } else {
      let { data } = await app.$axios.post(process.env.POSTS_URL,
      JSON.stringify({
          filter: { published: true, title_slug: params.title_slug },
          sort: {_created:-1},
          populate: 1
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })

      if (!data.entries[0]) {
        return error({ message: &#39;404 Page not found&#39;, statusCode: 404 })
      }

      return { post: data.entries[0] }
    }
  }
}
&lt;/script&gt;</code></pre>
<p>So as you can see we accept the payload as an argument in the asyncData method. We then check if we have the payload available (which is the post for that particular page in our case). If we do then we simply return it as <code>post</code> to the page data (you can check in Vue dev-tools).</p>
<p>If we don&#39;t have a payload i.e. when running our dev server then we simply send a post request to Cockpit. Notice the filter object in the request body that asks for the post with the same title_slug as the requested page. We can then check if this post exists in the response, if it does we return it and if not return the 404 error page.</p>
<p>Fire up the dev server again with <code>npm run dev</code>. You should have something that looks like this.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/20/5b2a9462bd065individual-post.png" alt="Individual Post"> </p>
</div>

<p>Now you may have noticed our markdown is not being parsed and it looks really messy. Don&#39;t worry we&#39;ll fix this soon!</p>
<p><strong>Note:</strong> If you&#39;re looking for some markdown placeholder text you can use <a href="https://jaspervdj.be/lorem-markdownum/">Lorum Markdown</a> to generate some.</p>
<h2 id="parsing-our-markdown">Parsing our Markdown</h2>
<p>Let&#39;s sort out our markdown parsing and code higlighting.</p>
<pre><code class="language-bash">npm install marked highlight.js --save-dev</code></pre>
<p>We&#39;ll make a global filter that we can use to parse our Markdown so create a file called <code>filters.js</code> in the plugins directory and put this in it:</p>
<pre><code class="language-javascript">import Vue from &#39;vue&#39;
import highlightjs from &#39;highlight.js&#39;
import marked, { Renderer } from &#39;marked&#39;

// Only import the languages that you need to keep our js bundle small
highlightjs.registerLanguage(&#39;php&#39;, require(&#39;highlight.js/lib/languages/php&#39;))
highlightjs.registerLanguage(&#39;javascript&#39;, require(&#39;highlight.js/lib/languages/javascript&#39;))
highlightjs.registerLanguage(&#39;css&#39;, require(&#39;highlight.js/lib/languages/css&#39;))

// Create your custom renderer.
const renderer = new Renderer()
renderer.code = (code, language) =&gt; {
  // Check whether the given language is valid for highlight.js.
  const validLang = !!(language &amp;&amp; highlightjs.getLanguage(language))
  // Highlight only if the language is valid.
  const highlighted = validLang ? highlightjs.highlight(language, code).value : code
  // Render the highlighted code with `hljs` class.
  return `&lt;pre&gt;&lt;code class=&quot;hljs ${language}&quot;&gt;${highlighted}&lt;/code&gt;&lt;/pre&gt;`
}

// Set the renderer to marked.
marked.setOptions({ renderer })

Vue.filter(&#39;parseMd&#39;, function(content) {
    return marked(content)
})</code></pre>
<p>Make sure you also add the following to nuxt.config.js underneath the head:{...} property</p>
<pre><code class="language-javascript">plugins: [
  &#39;~/plugins/filters.js&#39;
],</code></pre>
<p>We can now use this filter globally!</p>
<p>Back in <code>_title_slug.vue</code> in the template where it says v-html we can now access our filter by putting:</p>
<pre><code class="language-javascript">v-html=&quot;$options.filters.parseMd(post.excerpt + &#39;\n&#39; + post.content)&quot;</code></pre>
<p>I know this isn&#39;t the prettiest solution but unfortunately we can&#39;t just pipe filters using &#39;|&#39; like we would usually - <code>{{ some-markdown | parseMd }}</code> as it isn&#39;t possible in v-html.</p>
<p>You can create a method to call instead if you would like to tidy it up.</p>
<p>Back in nuxt.config.js update the css: property to include a theme for highlight.js - <a href="https://jmblog.github.io/color-themes-for-highlightjs/">full list here.</a></p>
<pre><code class="language-javascript"> css: [
  &#39;@/assets/css/main.css&#39;,
  &#39;highlight.js/styles/dracula.css&#39;
],</code></pre>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/20/5b2a9b9a63367markdown-parsed.png" alt="Individual Post"> </p>
</div>

<p>That&#39;s starting to look a bit more like it!</p>
<h2 id="generating-our-category-routes">Generating our Category Routes</h2>
<p>Okay, so we&#39;ve got our individual blog posts and their routes but we now want to generate routes for the different <code>post categories</code> based on their tags.</p>
<p>For example if we have a post tagged <code>vue</code> we want to be able to click on this tag to see all other posts that have been tagged <code>vue</code>.</p>
<p>So lets go back to nuxt.config.js and update our routes method in the generate: property.</p>
<p>Just before we do let&#39;s add a package that lets us work with collections so we can easily get the data we need from our Cockpit response.</p>
<pre><code class="language-bash">npm install collect.js --save-dev</code></pre>
<p>Make sure to add <code>const collect = require(&#39;collect.js&#39;)</code> at the top of our nuxt.config.js too.</p>
<p>Update the generate property in nuxt.config.js so that is resembles the below.</p>
<pre><code class="language-javascript">generate: {
  routes: async () =&gt; {
    let { data } = await axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })

    const collection = collect(data.entries)

    let tags = collection.map(post =&gt; post.tags)
    .flatten()
    .unique()
    .map(tag =&gt; {
      let payload = collection.filter(item =&gt; {
        return collect(item.tags).contains(tag)
      }).all()

      return {
        route: `category/${tag}`,
        payload: payload
      }
    }).all()

    let posts = collection.map(post =&gt; {
      return {
        route: post.title_slug,
        payload: post
      }
    }).all()

    return posts.concat(tags)
  }
},</code></pre>
<p>So here we use the same data returned from Cockpit as previously. Only this time we first collect the post entries into a const called <code>collection</code>.</p>
<p>For our tags we first map the collection into a new collection of just the post tags. Then we flatten this and call unique() on it to give us a collection of unique tags. (We would normally run flatMap() instead of calling map() and then flatten() however it wouldn&#39;t work as expected for me with collect.js)</p>
<p>With this unique collection of tags we map them into the route and payload properties like we did previously. For the tag payload we simply filter the original collection and return only post entries that have the specified tag. </p>
<p>For the posts we can simply map them directly into their route and payloads.</p>
<p>Finally we just call <code>posts.concat(tags)</code> to join the two together and return this.</p>
<p>So now we&#39;ve got routes for our posts and a category page for each unique post tag!</p>
<h2 id="creating-our-category-page">Creating our Category page</h2>
<p>Since we&#39;ve set our category routes to be <code>/category/tag-name</code> we need to create a category directory inside the pages directory.</p>
<p>Inside the category directory create a new file called <code>_tag.vue</code> (following the same naming convention as before) and put the following inside:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;div class=my-8&gt;
      &lt;h1 class=&quot;mb-6&quot;&gt;Posts tagged with &quot;{{ category }}&quot;&lt;/h1&gt;
      &lt;ul class=&quot;flex flex-col w-full p-0&quot;&gt;
        &lt;li class=&quot;mb-6 w-full&quot; v-for=&quot;(post, key) in posts&quot; :key=&quot;key&quot;&gt;
          &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
            &lt;a v-for=&quot;(tag, key) in post.tags&quot; :key=&quot;key&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
          &lt;/div&gt;

          &lt;a :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            &lt;h2 class=&quot;my-2 text-gray-800 text-lg lg:text-xl font-bold&quot;&gt;
              {{ post.title }}
            &lt;/h2&gt;
          &lt;/a&gt;

          &lt;div class=&quot;page-content hidden md:block text-base mb-2&quot; v-html=&quot;post.excerpt&quot;&gt;
          &lt;/div&gt;
          &lt;a class=&quot;text-sm text-blue-400&quot; :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            Read more
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  async asyncData ({ app, params, error, payload }) {
    if (payload) {
      return { posts: payload, category: params.tag }
    } else {
      let { data } = await app.$axios.post(process.env.POSTS_URL,
      JSON.stringify({
          filter: { published: true, tags: { $has:params.tag } },
          sort: {_created:-1},
          populate: 1
        }),
      {
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
      })

      if (!data.entries[0]) {
        return error({ message: &#39;404 Page not found&#39;, statusCode: 404 })
      }

      return { posts: data.entries, category: params.tag }
    }
  }
}
&lt;/script&gt;</code></pre>
<p>This page is largely similar to our index.vue page in terms of the template. Notice that we again accept the payload from our nuxt.config.js if it&#39;s available. </p>
<p>If we don&#39;t have a payload then we make a post request to Cockpit and include in the filter <code>tags: { $has:params.tag }</code> this returns all posts that have a tag for that particular category. </p>
<p>We can&#39;t call params.tag directly in our template which is why we simply pass it to our data object as <code>category</code>.</p>
<p>In the next part we&#39;ll look at how to go about deploying our site and also adding some finishing touches.</p>
<p>You can find Part 3 here - <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-3-deployment">Part 3: Deployment</a> and see a live demo of the site on Netlify here - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Building a Static Blog with Nuxt.js and Cockpit Headless CMS - Part 1: Setup]]></title>
        <id>https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup</id>
        <link href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-1-setup">
        </link>
        <updated>2018-06-16T12:14:53Z</updated>
        <summary type="html"><![CDATA[If you've ever felt WordPress is too bloated and slow then you might want to try out building a statically generated blog, using a static site generator and a headless CMS.]]></summary>
        <content type="html"><![CDATA[<h2 id="what-well-be-building">What we&#39;ll be building</h2>
<blockquote>
<p>Updated for Nuxt 2 and Tailwindcss 1.0!</p>
</blockquote>
<p>Tldr; You can check out the GitHub repo of the finished blog <a href="https://github.com/willbrowningme/nuxt-cockpit-static-blog">here</a> and see a live demo on Netlify - <a href="https://nuxt-cockpit-static-blog.netlify.com/">https://nuxt-cockpit-static-blog.netlify.com</a></p>
<p>We&#39;ll be using the <code>generate</code> feature of <a href="https://nuxtjs.org">Nuxt.js</a> to generate a static blog and a headless CMS called <a href="https://getcockpit.com">Cockpit</a> for the api.</p>
<p>It will be a JAMstack project, trying to follow the <a href="https://jamstack.org/best-practices/">best practices</a> layed out.</p>
<p>The definition of the JAMstack given on <a href="https://jamstack.org/">jamstack.org</a> is: </p>
<blockquote>
<p>Modern web development architecture based on client-side JavaScript, reusable APIs, and prebuilt Markup.</p>
</blockquote>
<p>In our example we&#39;ll be writing <code>Markdown</code> in Cockpit for our posts that will be fetched by Nuxt.js and then parsed to HTML before generating our static blog.</p>
<h2 id="why-a-static-site">Why a Static Site?</h2>
<p>Here are just a few benefits of generating a static site:</p>
<ul>
<li>Better Performance</li>
<li>Higher Security</li>
<li>Cheaper, Easier Scaling</li>
<li>Better Developer Experience</li>
</ul>
<p>You can use a number of different static site generators such as Jekyll, Hugo, Next or Gatsby. There are also many different options for your headless CMS e.g. self hosted options like Strapi, Directus, Ponzu or you can use hosted options like Contentful, Netlify, Prismic or Storyblok.</p>
<p>For a more comprehensive list of headless CMSs - <a href="https://headlesscms.org/">https://headlesscms.org/</a></p>
<p>And for a list of static site generators - <a href="https://www.staticgen.com/">https://www.staticgen.com/</a></p>
<p>For the site we&#39;re building we&#39;ll be using Nuxt.js as I love working with Vue and also Cockpit as it&#39;s a PHP based Headless CMS and is very quick and easy to set up.</p>
<h2 id="website-structure">Website Structure</h2>
<p>We&#39;ll be keeping the headless CMS backend separate from the frontend site. So you will need to create a new app directory on your server called something like <code>cms-yourblog</code> and another site called <code>yourblog</code>. </p>
<p>You can then use <code>yourdomain.com</code> for the frontend and a subdomain such as <code>cms.yourdomain.com</code> for the backend. You can obviously use whatever subdomain you like.</p>
<h2 id="setting-up-cockpit">Setting up Cockpit</h2>
<p>I&#39;m skipping setting up in our local environment with version control etc. here just to speed things up. But you may want to set Cockpit up locally first.</p>
<p>We don&#39;t actually need to do much configuration for Cockpit, you can simply download the zip file into your cms-yourblog web root directory and unzip the contents. </p>
<p>The third and forth commands below simply move the contents of the unzipped cockpit-master directory up one level to the current web root directory and then remove the empty cockpit-master directory.</p>
<pre><code class="language-bash">cd /path/to/your/cms-yourblog/
wget &quot;https://github.com/agentejo/cockpit/archive/master.zip&quot;
unzip master.zip
mv cockpit-master/* cockpit-master/.[^.]* .
rmdir cockpit-master
rm master.zip</code></pre>
<p>You can then go to <code>cms.yourdomain.com/install</code> to finish off the installation process.</p>
<p>Once you&#39;ve set up your new password and username we can create a posts <code>collection.</code> You can think of collections in cockpit like you would a table in a database.</p>
<p>Our new posts collection will have the following fields:</p>
<ul>
<li><strong>published</strong> (type boolean) (options <code>{&quot;default&quot;: false, &quot;label&quot;: false}</code>)</li>
<li><strong>title</strong> (type text) (options <code>{&quot;slug&quot;: true}</code>)</li>
<li><strong>image</strong> (type asset)</li>
<li><strong>excerpt</strong> (type textarea) - we&#39;ll use this for our meta description</li>
<li><strong>content</strong> (type markdown)</li>
<li><strong>tags</strong> (type tags)</li>
</ul>
<p>Make sure to include the options in the provided JSON options field when adding the published and title fields.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/17/5b265ae2d783ccockpit-collections.png" alt="Cockpit Collections"></p>
</div>

<p>We can now head over to settings then api access where we will generate an API key so we can retreive our posts data.</p>
<p>You should see there is a &quot;MASTER API-KEY&quot; that you can generate. This key will have full permisions for your site so you should avoid using this if possible.</p>
<p>Where it says <code>Custom Keys</code> click add key to add a new custom key. Then in the rules section add the following: <code>/api/collections/get/posts</code></p>
<p>This means that our key will only have permission to access that particular end point for fetching blog posts. Add a small description too if you like.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/11/12/5be94679c3a32custom-api-key.png" alt="Custom API Key"></p>
</div>

<p>This means if our API Key was ever accidently exposed then an attacker would only be able to view posts and not create/delete them etc.</p>
<p>Create a couple of dummy post entries so we have some initial data to look at.</p>
<p>If you have <a href="https://www.getpostman.com/">Postman</a> or <a href="https://insomnia.rest/">Insomnia</a> installed you can then send a get request to:</p>
<p><code>https://cms.yourdomain.com/api/collections/get/posts?token=YOUR-API-TOKEN</code></p>
<p>This should return your posts in the <code>entries</code> array of the response. </p>
<p>Now that we&#39;ve got our basic CMS setup that can return our post data we can move onto setting up Nuxt.js for the frontend.</p>
<h2 id="setting-up-nuxtjs">Setting up Nuxt.js</h2>
<p>First of all we need to install Nuxt. We&#39;ll do this on our local computer and run the built in development server.</p>
<p>To install Nuxt run the following command:</p>
<pre><code class="language-bash">npx create-nuxt-app static-blog</code></pre>
<p>Where static-blog is the name of our app. It will ask a few questions, for <code>custom server framework</code> select none. For <code>custom UI framework</code> select none (we&#39;ll set tailwind up ourselves).</p>
<p>For the rendering mode select <code>Universal</code>. Select yes to use the <code>axios module</code>. We&#39;ll not bother with <code>eslint</code> or <code>prettier</code> for now so select no for both.</p>
<div class="blog-note">
    <b>Note:</b> Or if using Yarn. "yarn create nuxt-app static-blog"
</div>   

<p>This will create a folder called static-blog for our frontend, you can obviously call it whatever you like.</p>
<p>Next we need to enter the newly created directory and run the development server (it should have already installed our dependencies).</p>
<pre><code class="language-bash">cd static-blog
npm run dev</code></pre>
<p>You can now visit <code>http://localhost:3000</code> in your browser to see the site in action!</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/18/5b2779e41e10fnuxt-folders.png" alt="Nuxt Folders"></p>
</div>

<p>Open your preferred code editor (I&#39;ll be using <code>Visual Studio Code</code>) and take a look at the folder structure.</p>
<p>Nuxt automatically creates a route for each file in the pages directory.</p>
<p>So If we simply copy the index.vue file and rename it about.vue we will be able to visit it at <code>http://localhost:3000/about</code>.</p>
<p>We&#39;ll use the <a href="https://github.com/nuxt-community/dotenv-module">dotenv</a> node module so we can access our .env variables inside nuxt.config.js. This module will allow us to create a .env file in our project root that we can store our secret api token and url in.</p>
<p>You should also add <code>.env</code> to your .gitignore file to make sure you don&#39;t accidently commit and push the contents to Github etc.</p>
<pre><code class="language-bash">npm install dotenv --save-dev</code></pre>
<p>Once installed open up <code>nuxt.config.js</code> and add the following at the very top of the file:</p>
<pre><code class="language-javascript">require(&#39;dotenv&#39;).config()</code></pre>
<p>If you haven&#39;t already create a .env file at your project root and put the following inside:</p>
<pre><code class="language-env">URL=https://yourdomain.com
BASE_URL=https://cms.yourdomain.com
POSTS_URL=http://cms.yourdomain.com/api/collections/get/posts?token=YOUR-API-TOKEN</code></pre>
<p>Making sure to replace <code>YOUR-API-TOKEN</code> with the token we generated earlier in Cockpit.</p>
<p>We&#39;ll now be able to access these variables throughout our blog using <code>process.env.POSTS_URL</code> for example.</p>
<p>The reason we used the dotenv package and didn&#39;t just add our api key to nuxt.config.js in the <a href="https://nuxtjs.org/api/configuration-env#the-env-property">env:{...} property</a> is because this gets bundled up in a js file and exposed to the client. So someone would be able to simply open our <code>/_nuxt/xxxxxxxxxxxxxxxxxxxx.js</code> file and see our api key in plain text!</p>
<p>Install tailwind for our css framework (feel free to use any other css framework you like).</p>
<pre><code class="language-bash">npm install tailwindcss --save-dev</code></pre>
<h2 id="setting-up-tailwindcss-with-purgecss">Setting up Tailwindcss with Purgecss</h2>
<p>Next initiate the tailwind config file by running:</p>
<pre><code class="language-bash">./node_modules/.bin/tailwind init tailwind.config.js</code></pre>
<p>Create a new directory called css inside the assets directory and then create a file in here called <code>main.css</code> and add the following to it:</p>
<pre><code class="language-css">@tailwind base;

@tailwind components;

@tailwind utilities;</code></pre>
<p>Then install the following dependencies:</p>
<pre><code class="language-bash">npm install autoprefixer glob-all purgecss-webpack-plugin --save-dev</code></pre>
<p>This will allow us to compile our css and also remove any unused css using purgecss.</p>
<p>In the root of the project create a file called <code>postcss.config.js</code> and insert the following:</p>
<pre><code class="language-javascript">module.exports = {
  plugins: [
    require(&#39;tailwindcss&#39;)(&#39;./tailwind.config.js&#39;),
    require(&#39;autoprefixer&#39;)
  ]
}</code></pre>
<p>Back in nuxt.config.js add the following at the very top of the file above module.exports = {...</p>
<pre><code class="language-javascript">require(&#39;dotenv&#39;).config() // we already added this ealier when making our .env file
const PurgecssPlugin = require(&#39;purgecss-webpack-plugin&#39;)
const glob = require(&#39;glob-all&#39;)
const path = require(&#39;path&#39;)
import axios from &#39;axios&#39; // we&#39;ll need this later for our dynamic routes

class TailwindExtractor {
  static extract(content) {
    return content.match(/[A-z0-9-:\/]+/g) || [];
  }
}</code></pre>
<p>then add our main.css file and update the build: {... object like this:</p>
<pre><code class="language-javascript">css: [
  &#39;@/assets/css/main.css&#39;
],
/*
** Build configuration
*/    
build: {
  extractCSS: true,
  /*
  ** You can extend webpack config here
  */
  extend (config, { isDev }) {
    if (!isDev) {
      // Remove unused CSS using purgecss. See https://github.com/FullHuman/purgecss
      // for more information about purgecss.
      config.plugins.push(
        new PurgecssPlugin({
          // Specify the locations of any files you want to scan for class names.
          paths: glob.sync([
            path.join(__dirname, &#39;./pages/**/*.vue&#39;),
            path.join(__dirname, &#39;./layouts/**/*.vue&#39;),
            path.join(__dirname, &#39;./components/**/*.vue&#39;)
          ]),
          extractors: [
            {
              extractor: TailwindExtractor,
              // Specify the file extensions to include when scanning for
              // class names.
              extensions: [&quot;html&quot;, &quot;vue&quot;]
            }
          ],
          whitelist: [
            &quot;html&quot;,
            &quot;body&quot;,
            &quot;ul&quot;,
            &quot;ol&quot;,
            &quot;pre&quot;,
            &quot;code&quot;,
            &quot;blockquote&quot;
          ],
          whitelistPatterns: [/\bhljs\S*/]
        })
      )
    }
  }
}</code></pre>
<p>We&#39;ve added a few tags to the whitelist to make sure that purgecss doesn&#39;t remove any styles that apply to them.</p>
<p>We should now have tailwindcss up and running with purgecss to remove any unused styles when we come round to running <code>npm run generate</code>.</p>
<p>Fire up the dev server with <code>npm run dev</code> just to make sure everything still works.</p>
<h2 id="updating-our-default-layout">Updating our default layout</h2>
<p>Inside the components directory create three new files; <code>PageHeader.vue</code> <code>PageNav.vue</code> and <code>PageFooter.vue</code> with the following contents respectively:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;header class=&quot;text-center&quot;&gt;
    &lt;a class=&quot;text-gray-800 text-3xl font-bold&quot; href=&quot;/&quot;&gt;
      &lt;h1&gt;
        Static Blog
      &lt;/h1&gt;
    &lt;/a&gt;
  &lt;/header&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;nav class=&quot;text-center my-4&quot;&gt;
    &lt;a href=&quot;/&quot; class=&quot;p-2 text-sm sm:text-lg inline-block text-gray-800 hover:underline&quot;&gt;Blog&lt;/a&gt;
    &lt;a href=&quot;/about&quot; class=&quot;p-2 text-sm sm:text-lg p-2 inline-block text-gray-800 hover:underline&quot;&gt;About&lt;/a&gt;
  &lt;/nav&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-html">&lt;template&gt;
  &lt;footer class=&quot;flex justify-center my-4&quot;&gt;
    &lt;div class=&quot;text-gray-800 text-sm&quot;&gt;
      A static blog built with Nuxt.js, Tailwindcss and Cockpit.
    &lt;/div&gt;
  &lt;/footer&gt;
&lt;/template&gt;</code></pre>
<p>Now go over to the layouts directory and update <code>default.vue</code> so that it looks like this:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;flex flex-row justify-center w-screen&quot;&gt;
    &lt;div class=&quot;overflow-hidden content flex flex-col p-4 md:p-8&quot;&gt;
      &lt;page-header/&gt;
      &lt;page-nav/&gt;
      &lt;nuxt/&gt;
      &lt;page-footer/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
import PageHeader from &#39;~/components/PageHeader.vue&#39;
import PageNav from &#39;~/components/PageNav.vue&#39;
import PageFooter from &#39;~/components/PageFooter.vue&#39;

export default {
  components: {
    PageHeader,
    PageNav,
    PageFooter
  }
}
&lt;/script&gt;</code></pre>
<p>Delete any of the default styles that were there as we won&#39;t be needing them.</p>
<p>Also add the following style to our main.css file underneath @tailwind components:</p>
<pre><code class="language-css">.content {
  width: 50rem;
}

.markdown p {
  @apply mt-0 mb-6;
}

.markdown ul {
  @apply mb-6;
}

pre {
  @apply my-8;
}</code></pre>
<p>Now we just need to update index.vue in the pages directory.</p>
<h2 id="fetching-and-displaying-our-posts">Fetching and displaying our posts</h2>
<p>Make sure that you have the axios module loaded correctly in your <code>nuxt.config.js</code></p>
<pre><code class="language-js">/*
** Nuxt.js modules
*/
modules: [
  // Doc: https://github.com/nuxt-community/axios-module#usage
  &#39;@nuxtjs/axios&#39;
],</code></pre>
<p>In the index.vue page update the file so that it resembles the following:</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;section&gt;
    &lt;div class=my-8&gt;
      &lt;ul class=&quot;flex flex-col w-full p-0&quot;&gt;
        &lt;li class=&quot;mb-6 w-full&quot; v-for=&quot;(post, key) in posts&quot; :key=&quot;key&quot;&gt;
          &lt;div class=&quot;text-gray-600 font-bold text-sm tracking-wide&quot;&gt;
            &lt;a v-for=&quot;tag in post.tags&quot; :key=&quot;tag&quot; :href=&quot;&#39;/category/&#39;+tag&quot; class=&quot;ml-1&quot;&gt;{{ tag }}&lt;/a&gt;
          &lt;/div&gt;

          &lt;a :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            &lt;h2 class=&quot;my-2 text-gray-800 text-lg lg:text-xl font-bold&quot;&gt;
              {{ post.title }}
            &lt;/h2&gt;
          &lt;/a&gt;

          &lt;div class=&quot;page-content hidden md:block text-base mb-2&quot; v-html=&quot;post.excerpt&quot;&gt;
          &lt;/div&gt;
          &lt;a class=&quot;text-sm text-blue-400 no-underline&quot; :href=&quot;&#39;/&#39;+post.title_slug&quot;&gt;
            Read more
          &lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/template&gt;</code></pre>
<pre><code class="language-javascript">&lt;script&gt;
export default {
  async asyncData ({ app }) {
    const { data } = await app.$axios.post(process.env.POSTS_URL,
    JSON.stringify({
        filter: { published: true },
        sort: {_created:-1},
        populate: 1
      }),
    {
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; }
    })

    return { posts: data.entries }
  }
}
&lt;/script&gt;</code></pre>
<p>Nuxt includes the asyncData method which can be called on the server side before the component data has been set. You can read more about this method here - <a href="https://nuxtjs.org/guide/async-data">https://nuxtjs.org/guide/async-data</a></p>
<p>What we are doing is retrieving the posts from Cockpit and then setting these as the component data in a posts variable.</p>
<p>If you visit the site now at <code>http://localhost:3000</code> you should see the post entries you&#39;ve added from Cockpit.</p>
<p>You should now have something that looks like this.</p>
<div class="blog-image">

<p><img src="https://api.willbrowning.me/storage/uploads/2018/06/19/5b28bf9fc1f0cstatic-blog-layout.png" alt="satic-blog-layout"></p>
</div>

<p>In the next part we&#39;ll look at generating our dynamic routes in <code>nuxt.config.js</code> for our individual blog posts based on their <code>title slug</code> and also setting up our category page to display posts depending on their tags.</p>
<p>You can find Part 2 here - <a href="https://willbrowning.me/building-a-static-blog-with-nuxt-js-and-cockpit-headless-cms-part-2-dynamic-routes">Part 2: Dynamic Routes</a></p>
]]></content>
    </entry>
</feed>